#ifndef AVL_{{name.upper()}}_{{type.upper()}}
#define AVL_{{name.upper()}}_{{type.upper()}}

#pragma once
{% import 'helpers.jin' as h %}

/// avl: A Vector Library
/// \author Thomas Pollak
namespace avl {
	
	{% if dim==0 %}
	/// \defgroup Free functions for arbitrary vectors
	/// @{
	
	//component type helper
	avl_ainl_res constexpr auto cmp(const v& vec) noexcept -> rem_const_ref_t<decltype(vec[0])>{% if type=='h' %};
	{% else %} {
		return vec[0];
	}
	{% endif %}
	
	/// @name Getters and Setters
	/// @{
	
	/// Set a single component by index from 0 to dim-1
	avl_ainl constexpr auto set(v& vec, const s::size_t idx, const sc scalar) noexcept(ndebug) -> void{% if type=='h' %};
	{% else %} {
		static_assert(eq<decltype(vec[0]), decltype(scalar)>::value, "Supply a scalar of the vectors element type.");
		assert(idx < dim< rem_const_ref_t< decltype(vec) > >::value);
		vec[idx] = scalar;
	}
	{% endif %}
	
	/// Access the vector components as value by a range checked index (assert) from 0 to dim-1
	avl_ainl_res constexpr auto get(const v& vec, const s::size_t idx) noexcept(ndebug) ->decltype(cmp(vec)){% if type=='h' %};
	{% else %} {
		//decltype(cmp(vec)) { //causes the compiler to crash
		assert(idx < dim< rem_const_ref_t< decltype(vec) > >::value);
		return vec[idx];
	}
	{% endif %}
	
	/// Set a single component by index from 0 to dim-3
	template<s::size_t _Idx>
	avl_ainl constexpr auto set(v& vec, const sc scalar) noexcept -> void{% if type=='h' %};
	{% else %} {
		static_assert(eq<decltype(vec[_Idx]), decltype(scalar)>::value, "Supply a scalar of the vectors element type.");
		static_assert(/*is_simd<decltype(vec)>::value ||*/ _Idx < dim< rem_const_ref_t< decltype(vec) > >::value, "Index out of range");
		vec[_Idx] = scalar;
	}
	{% endif %}
	
	/// Access the vector components as value by a range checked index (assert) from 0 to dim-1
	template<s::size_t _Idx>
	avl_ainl_res constexpr auto get(const v& vec) noexcept -> decltype(cmp(vec)){% if type=='h' %};
	{% else %} {
		//decltype(cmp(vec))  { //also yields a compiler problem (but not a segfault)
		static_assert(/*is_simd<decltype(vec)>::value ||*/ _Idx < dim< rem_const_ref_t< decltype(vec) > >::value, "Index out of range");
		return vec[_Idx];
	}
	{% endif %}
	
	/// @}
	/// @name Vector Length Operations
	/// @{
	
	/// Returns a new vector with the requested length
	avl_ainl_res constexpr auto len_mk(const v& vec, const sc new_len) noexcept(ndebug){% if type=='h' %};
	{% else %} {
		assert(new_len!=decltype(new_len){0});
		return mul_mk(vec, new_len / len(vec));
	}
	{% endif %}
	
	/// Set the length of the vector
	avl_ainl constexpr auto len_set(v& vec, const sc new_len) noexcept -> void{% if type=='h' %};
	{% else %} {
		assert(new_len!=decltype(new_len){0});
		mul_set(vec, new_len / len(vec));
	}
	{% endif %}
	
	/// Calculate the length of the vector, prefere len_sqr when comparing distances (faster)
	avl_ainl_res constexpr auto len(const v& vec) noexcept -> decltype(cmp(vec)){% if type=='h' %};
	{% else %} {
		//len_sqr will never return any negativ values so we can gurantee noexcept
		return static_cast<decltype(cmp(vec))>( s::sqrt( len_sqr(vec) ) );
	}
	{% endif %}
	
	/// Returns a normalized vector
	avl_ainl_res constexpr auto norm_mk(const v& vec) noexcept(ndebug){% if type=='h' %};
	{% else %} {
		return div_mk(vec, len(vec)); //div might assert in debug
	}
	{% endif %}
	
	/// Returns a normalized vector
	avl_inl_res constexpr auto norm_mk(const v& vec, const v& vec_if_zero_len) noexcept(ndebug){% if type=='h' %};
	{% else %} {
		auto l = len(vec);
		if(l==decltype(l){0})
			return vec_if_zero_len;
		else
			return div_mk(vec, l); //div might assert in debug
	}
	{% endif %}
	
	/// Normalize the current vector
	avl_ainl constexpr auto norm_set(v& vec) noexcept(ndebug) -> void{% if type=='h' %};
	{% else %} {
		div_set(vec, len(vec));
	}
	{% endif %}
	
	/// Normalize the current vector
	avl_inl constexpr auto norm_set(v& vec, const v& vec_if_zero_len) noexcept(ndebug) -> void{% if type=='h' %};
	{% else %} {
		auto l = len(vec);
		if(l==decltype(l){0})
			set_all(vec, vec_if_zero_len);
		else
			div_set(vec, len(vec));
	}
	{% endif %}
	
	/// Normalize the current vector
	avl_ainl_res constexpr auto norm(v& vec) noexcept(ndebug) -> decltype(vec){% if type=='h' %};
	{% else %} {
		div_set(vec, len(vec));
		return vec;
	}
	{% endif %}
	
	/// Normalize the current vector
	avl_inl_res constexpr auto norm(v& vec, const v& vec_if_zero_len) noexcept(ndebug) -> decltype(vec){% if type=='h' %};
	{% else %} {
		auto l = len(vec);
		if(l==decltype(l){0})
			set_all(vec, vec_if_zero_len);
		else
			div_set(vec, len(vec));
		return vec;
	}
	{% endif %}
	
	/// @}
	/// @name Vector Operations With Scalar Results
	/// @{
	
	avl_ainl_res constexpr auto angle_rd(const v& vec, const v& other) noexcept -> decltype(cmp(vec)){% if type=='h' %};
	{% else %} {
		return s::acos( dot(vec, other) / (len(vec) * len(other)) );
	}
	{% endif %}
	
// 	avl_ainl_res constexpr auto angle_dg(const v& vec, const v& other) noexcept -> decltype(cmp(vec)){% if type=='h' %};
	{% else %} {
// 		return s::acos( dot(vec, other) / (len(vec) * len(other)) ) * cnst<cmp>::to_deg;
// 	}
	{% endif %}
	
	/// @}
	
	/// @}
	{% else %}
	/// \defgroup Free functions for {{dim}} component vectors
	/// @{
	
	/// @name Getters and Setters
	/// @{
	
	/// Set all vector components to the same scalar
	avl_ainl constexpr auto set_all({{name}}& vec, const sc scalar) noexcept -> void{% if type=='h' %};
	{% else %} {
		static_assert(eq<decltype(vec[0]), decltype(scalar)>::value, "Supply a scalar of the vectors element type.");
		{% for idx in range(dim) %}
		vec[{{idx}}] = scalar;
		{% endfor %}
	} {% endif %}
	
	/// Set all vector components individually
	avl_ainl constexpr auto set_all({{name}}& vec{% for cmp in param %}, const sc {{cmp}}{% endfor %}) noexcept -> void{% if type=='h' %};
	{% else %} {
		{% for idx in range(dim) %}
		static_assert(eq<decltype(vec[{{idx}}]), decltype({{param[idx]}})>::value, "Supply a scalar of the vectors element type for {{param[idx]}}.");
		{% endfor %}
		{% for idx in range(dim) %}
		vec[{{idx}}] = {{param[idx]}};
		{% endfor %}
	}
	{% endif %}
	
	/// Set all vector components individually
	avl_ainl constexpr auto set_all({{name}}& vec, const sc scalars[{{dim}}]) noexcept -> void{% if type=='h' %};
	{% else %} {
		{% for idx in range(dim) %}
		static_assert(eq<decltype(vec[{{idx}}]), decltype(scalars[{{idx}}])>::value, "Supply a scalar of the vectors element type.");
		{% endfor %}
		{% for idx in range(dim) %}
		vec[{{idx}}] = scalars[{{idx}}];
		{% endfor %}
	}
	{% endif %}
	
	/// Set all vector components individually
	template <s::size_t _Dim>
	avl_ainl constexpr auto set_all({{name}}& vec, const sc* scalars) noexcept -> void{% if type=='h' %};
	{% else %} {
		static_assert(_Dim>={{dim}}, "Supply at least {{dim}} scalars.");
		{% for idx in range(dim) %}
		static_assert(eq<decltype(vec[{{idx}}]), decltype(scalars[{{idx}}])>::value, "Supply a scalar of the vectors element type.");
		{% endfor %}
		{% for idx in range(dim) %}
		vec[{{idx}}] = scalars[{{idx}}];
		{% endfor %}
	}
	{% endif %}
	
	/// @}
	/// @name General Vector Operations
	/// @{
	{% for op_name, op in [("add", "+"), ("sub", "-"), ("mul", "*"), ("div", "/")] %}
	
	// {{op_name}} make
	
	avl_ainl_res constexpr auto {{op_name}}_mk(const {{name}}& vec, const {{name}}& other) noexcept{% if type=='h' %};
	{% else %} {
		{% if op_name=="div" %}
		{% for idx in range(dim) %}
		assert(get<{{idx}}>(other)!=decltype(other[{{idx}}]){0});
		{% endfor %}
		{% endif %}
		return rem_const_ref_t< decltype(vec) > { {{ h.cmp_wise_op("get<?>(vec) @ get<?>(other)", op, ", ", dim) }} };
	}
	{% endif %}
	
	avl_ainl_res constexpr auto {{op_name}}_mk(const {{name}}& vec, const sc scalar) noexcept{% if type=='h' %};
	{% else %} {
		{% if op_name=="div" %}
		assert(scalar!=decltype(scalar){0});
		{% endif %}
		return rem_const_ref_t< decltype(vec) > { {{ h.cmp_wise_op("get<?>(vec) @ scalar", op, ", ", dim) }} };
	}
	{% endif %}
	
	// {{op_name}} set
	
	avl_ainl constexpr auto {{op_name}}_set({{name}}& vec, const {{name}}& other) noexcept -> void{% if type=='h' %};
	{% else %} {
		{% if op_name=="div" %}
		{% for idx in range(dim) %}
		assert(get<{{idx}}>(other)!=decltype(other[{{idx}}]){0});
		{% endfor %}
		{% endif %}
		set_all(vec, {{ h.cmp_wise_op("get<?>(vec) @ get<?>(other)", op, ", ", dim) }} );
	}
	{% endif %}
	
	avl_ainl constexpr auto {{op_name}}_set({{name}}& vec, const sc scalar) noexcept -> void{% if type=='h' %};
	{% else %} {
		{% if op_name=="div" %}
		assert(scalar!=decltype(scalar){0});
		{% endif %}
		set_all(vec, {{ h.cmp_wise_op("get<?>(vec) @ scalar", op, ", ", dim) }} );
	}
	{% endif %}
	
	// {{op_name}} (chaining)
	
	avl_ainl_res constexpr auto {{op_name}}({{name}}& vec, const {{name}}& other) noexcept -> decltype(vec){% if type=='h' %};
	{% else %} {
		{% if op_name=="div" %}
		{% for idx in range(dim) %}
		assert(get<{{idx}}>(other)!=decltype(other[{{idx}}]){0});
		{% endfor %}
		{% endif %}
		set_all(vec, {{ h.cmp_wise_op("get<?>(vec) @ get<?>(other)", op, ", ", dim) }} );
		return vec;
	}
	{% endif %}
	
	avl_ainl_res constexpr auto {{op_name}}({{name}}& vec, const sc scalar) noexcept -> decltype(vec){% if type=='h' %};
	{% else %} {
		{% if op_name=="div" %}
		assert(scalar!=decltype(scalar){0});
		{% endif %}
		set_all(vec, {{ h.cmp_wise_op("get<?>(vec) @ scalar", op, ", ", dim) }} );
		return vec;
	}
	{% endif %}
	{% endfor %}
	
	{% if dim==2 %}
	{% include 'v2.jin' %}
	{% elif dim==3 %}
	{% include 'v3.jin' %}
	{% else%}
	{% include 'v4.jin' %}
	{% endif %}
	
	/// @}
	/// @name Vector Length Operations
	/// @{
	
	/// Calculate the square length of the vector
	avl_ainl_res constexpr auto len_sqr(const {{name}}& vec) noexcept -> decltype(cmp(vec)){% if type=='h' %};
	{% else %} {
		{% for idx in range(dim) %}
		const auto cmp{{idx}} = get<{{idx}}>(vec);
		{% endfor %}
		return {{ h.cmp_wise_op("cmp? @ cmp?", "*", " + ", dim) }};
	}
	{% endif %}
	
	/// @}
	/// @name Vector Operations With Scalar Results
	/// @{
	
	avl_ainl_res constexpr auto dot(const {{name}}& vec, const {{name}}& other) noexcept -> decltype(cmp(vec)){% if type=='h' %};
	{% else %} {
		return {{ h.cmp_wise_op("get<?>(vec) @ get<?>(other)", "*", " + ", dim) }};
	}
	{% endif %}
	
	/// @}
	
	/// @}
	{% endif %}
}
#endif // AVL_{{name.upper()}}_{{type.upper()}}
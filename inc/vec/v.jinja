###-
###- Import jinja helpers
###-
//%- import 'helpers.jin' as h
//%- from 'avl.jin' import func, section, endSection with context
//%- from 'avl.jin' import vecReadCmp, vecWriteCmp, vecRetCmp with context
//%- from 'avl.jin' import checkDim, checkCmpType with context
//%- from 'avl.jin' import vecCreate, vecCreateRnd, vecCreateSeq, vecCreateZero with context
//%- from 'avl.jin' import arrCreate, arrCreateRnd, arrCreateSeq with context
//%- from 'avl.jin' import getRndInt, getRndFloat with context
//%- from 'avl.jin' import loop_, loop_if, if_then with context
//%- from 'avl.jin' import scalarCreate, scalarCreateRnd with context
###-
###- Define global strings so that they can be used like variables
###-
//%- set vec = 'vec'
//%- set arr = 'arr'
//%- set _Idx = '_Idx'
//%- set idx = 'idx'
//%- set scalar = 'scalar'
//%- set supplyScalar = '"Supply a scalar of the vectors element type."'
//%- if filetype!="test"
#ifndef AVL_$filename.upper()@_$filetype.upper()@
#define AVL_$filename.upper()@_$filetype.upper()@

#pragma once

/// avl: A Vector Library
/// \author Thomas Pollak
namespace avl
$'{\n'@
//%- else
#include "../../ext/catch/catch.hpp"
#include "../../inc/avl.h"

using namespace avl;

//% endif
$section("Helper functions")@
	
	//% call func([0], "//Component type helper")
	avl_ainl_res constexpr auto cmp(const $vecPar@& vec) noexcept -> $vecRetCmp(vec)@
	{
		return $vecReadCmp(vec, 0)@;
	}
	test_case
	{
		$vecCreate(vec)@;
		static_assert($checkCmpType(vec, 0, "cmp(vec)")@, $supplyScalar@);
	}
	//% endcall
	
$endSection()@
$section("Getters and setters for all vectors")@
	
	//% call func([0], "///Access the vector components by a range checked index from 0 to dim-1")
	avl_ainl_res constexpr auto get($vecPar@& vec, const s::size_t idx) noexcept(ndebug||exuse) -> decltype(cmp(vec))
	{
		assert($checkDim(vec, idx)@);
		return $vecReadCmp(vec, idx)@;
	}
	test_case
	{
		$vecCreateSeq(vec)@;
		
		//% for i in range(dim)
		REQUIRE( get(vec, $i@) == Approx( $i@ ) );
		//% endfor
	}
	//% endcall
	
	//% call func([0], "/// Access the vector components by a static range checked index from 0 to dim-1")
	template<s::size_t _Idx> avl_ainl_res constexpr auto get(const $vecPar@& vec) noexcept -> decltype(cmp(vec))
	{
		static_assert($checkDim(vec, _Idx)@, "Index is out of range");
		return $vecReadCmp(vec, _Idx)@;
	}
	test_case
	{
		$vecCreateSeq(vec)@;
		
		//% for i in range(dim)
		REQUIRE( get<$i@>(vec) == Approx( $i@ ) );
		//% endfor
	}
	//% endcall
	
	//% call func([0], "///Set a single component by index from 0 to dim-1")
	avl_ainl constexpr auto set($vecPar@& vec, const s::size_t idx, const $scalarPar@ scalar) noexcept(ndebug||exuse) -> void
	{
		static_assert($checkCmpType(vec, idx, scalar)@, $supplyScalar@);
		assert($checkDim(vec, idx)@);
		$vecWriteCmp(vec, idx, scalar)@;
	}
	test_case
	{
		$vecCreate(vec)@;
		$arrCreateRnd(arr)@;
		
		//% for i in range(dim)
		set(vec, $i@, arr[$i@]);
		REQUIRE( get(vec, $i@) == Approx( arr[$i@] ) );
		//% endfor
	}
	//% endcall
	
	//% call func([0], "/// Set a single component by static index from 0 to dim-1")
	template<s::size_t _Idx> avl_ainl constexpr auto set($vecPar@& vec, const $scalarPar@ scalar) noexcept -> void
	{
		static_assert($checkCmpType(vec, _Idx, scalar)@, $supplyScalar@);
		static_assert($checkDim(vec, _Idx)@, "Index is out of range");
		$vecWriteCmp(vec, _Idx, scalar)@;
	}
	test_case
	{
		$vecCreateSeq(vec)@;
		$arrCreateRnd(arr)@;
		
		//% for i in range(dim)
		set<$i@>(vec, arr[ $i@ ]);
		REQUIRE( get<$i@>(vec) == Approx( arr[$i@] ) );
		//% endfor
	}
	//% endcall
	
$endSection()@
$section("Dimension independent vector length operations")@
	
	//% call func([0], "/// Returns a new vector with the requested length")
	avl_ainl_res constexpr auto len_mk(const $vecPar@& vec, const $scalarPar@ new_len) noexcept(ndebug|exuse)
	{
		const decltype(newlen) length = len(vec);
		assert(length!=decltype(length){0});
		return mul_mk(vec, new_len / length));
	}
	test_case
	{
		$vecCreateRnd(vec)@;
		auto new_len = $getRndFloat()@;
		auto len_vec = len_mk(vec, new_len);
		auto res = len(len_vec);
		
		REQUIRE( res == Approx(new_len) );
		
		//test edge case 0.0
		decltype(new_len) zero = {0};
		auto zero_vec = len_mk(vec, zero);
		//% for i in range(dim)
		REQUIRE( get<$i@>(zero_vec) == Approx( zero ) );
		//% endfor
	}
	//% endcall
	
	//% call func([0], "/// Set the length of the vector")
	avl_ainl constexpr auto len_set($vecPar@& vec, const $scalarPar@ new_len) noexcept(ndebug|exuse) -> void
	{
		const decltype(newlen) length = len(vec);
		assert(length!=decltype(length){0});
		mul_set(vec, new_len / length);
	}
	test_case
	{
		$vecCreateRnd(vec)@;
		auto new_len = $getRndFloat()@;
		len_set(vec, new_len);
		auto res = len(vec);
		
		REQUIRE( res == Approx(new_len) );
		
		//test edge case 0.0
		decltype(new_len) zero = {0};
		len_set(vec, zero);
		//% for i in range(dim)
		REQUIRE( get<$i@>(vec) == Approx( zero ) );
		//% endfor
	}
	//% endcall
	
	//% call func([0], "/// Calculate the length of the vector, prefere len_sqr when comparing distances")
	avl_ainl_res constexpr auto len(const $vecPar@& vec) noexcept -> decltype(cmp(vec))
	{
		//len_sqr will never return any negativ values so we can gurantee noexcept
		return static_cast<decltype(cmp(vec))>( s::sqrt( len_sqr(vec) ) );
	}
	test_case
	{
		$vecCreateRnd(vec)@;
		auto res = len(vec);
		auto square_len = /*% call loop_(range(dim), ' + ') %*/get<#>(vec) * get<#>(vec)/*% endcall %*/;
		REQUIRE( res == Approx( s::sqrt( square_len ) ) );
		
		//test edge case 0.0
		$vecCreateZero(vec)@;
		auto res = len(vec);
		decltype(res) zero = {0};
		//% for i in range(dim)
		REQUIRE( get<$i@>(vec) == Approx( zero ) );
		//% endfor
	}
	//% endcall
	
	/// Returns a normalized vector
	avl_ainl_res constexpr auto norm_mk(const v& vec) noexcept(ndebug)/*% if filetype=='h' %*/;
	/*% else %*/ {
		return div_mk(vec, len(vec)); //div might assert in debug
	}
	/*% endif %*/
	
	/// Returns a normalized vector
	avl_inl_res constexpr auto norm_mk(const v& vec, const v& vec_if_zero_len) noexcept(ndebug)/*% if filetype=='h' %*/;
	/*% else %*/ {
		auto l = len(vec);
		if(l==decltype(l){0})
			return vec_if_zero_len;
		else
			return div_mk(vec, l); //div might assert in debug
	}
	/*% endif %*/
	
	/// Normalize the current vector
	avl_ainl constexpr auto norm_set(v& vec) noexcept(ndebug) -> void/*% if filetype=='h' %*/;
	/*% else %*/ {
		div_set(vec, len(vec));
	}
	/*% endif %*/
	
	/// Normalize the current vector
	avl_inl constexpr auto norm_set(v& vec, const v& vec_if_zero_len) noexcept(ndebug) -> void/*% if filetype=='h' %*/;
	/*% else %*/ {
		auto l = len(vec);
		if(l==decltype(l){0})
			set_all(vec, vec_if_zero_len);
		else
			div_set(vec, len(vec));
	}
	/*% endif %*/
	
	/// Normalize the current vector
	avl_ainl_res constexpr auto norm(v& vec) noexcept(ndebug) -> decltype(vec)/*% if filetype=='h' %*/;
	/*% else %*/ {
		div_set(vec, len(vec));
		return vec;
	}
	/*% endif %*/
	
	/// Normalize the current vector
	avl_inl_res constexpr auto norm(v& vec, const v& vec_if_zero_len) noexcept(ndebug) -> decltype(vec)/*% if filetype=='h' %*/;
	/*% else %*/ {
		auto l = len(vec);
		if(l==decltype(l){0})
			set_all(vec, vec_if_zero_len);
		else
			div_set(vec, len(vec));
		return vec;
	}
	/*% endif %*/

$endSection()@
$section("Dimension independent vector operations with scalar results")@
	
	avl_ainl_res constexpr auto angle_rd(const v& vec, const v& other) noexcept -> decltype(cmp(vec))/*% if filetype=='h' %*/;
	/*% else %*/ {
		return s::acos( dot(vec, other) / (len(vec) * len(other)) );
	}
	/*% endif %*/
	
// 	avl_ainl_res constexpr auto angle_dg(const v& vec, const v& other) noexcept -> decltype(cmp(vec))/*% if filetype=='h' %*/;
	/*% else %*/ {
// 		return s::acos( dot(vec, other) / (len(vec) * len(other)) ) * cnst<cmp>::to_deg;
// 	}
	/*% endif %*/
	
$endSection()@
$section("Getter and setters for "+dim|string+" component vectors")@
	
	/// Set all vector components to the same scalar
	avl_ainl constexpr auto set_all($vecPar@& vec, const sc scalar) noexcept -> void/*% if filetype=='h' %*/;
	/*% else %*/ {
		static_assert(eq<decltype(vec[0]), decltype(scalar)>::value, "Supply a scalar of the vectors element filetype.");
		/*% for idx in range(dim) %*/
		vec[ $idx@ ] = scalar;
		/*% endfor %*/
	} /*% endif %*/
	
	/// Set all vector components individually
	avl_ainl constexpr auto set_all($vecPar@& vec/*% for cmp in param %*/, const sc $cmp@/*% endfor %*/) noexcept -> void/*% if filetype=='h' %*/;
	/*% else %*/ {
		/*% for idx in range(dim) %*/
		static_assert(eq<decltype(vec[ $idx@ ]), decltype($param[idx]@)>::value, "Supply a scalar of the vectors element type for $param[idx]@.");
		/*% endfor %*/
		/*% for idx in range(dim) %*/
		vec[ $idx@ ] = $param[idx]@;
		/*% endfor %*/
	}
	/*% endif %*/
	
	/// Set all vector components individually
	avl_ainl constexpr auto set_all($vecPar@& vec, const sc scalars[ $dim@ ]) noexcept -> void/*% if filetype=='h' %*/;
	/*% else %*/ {
		/*% for idx in range(dim) %*/
		static_assert(eq<decltype(vec[ $idx@ ]), decltype(scalars[ $idx@ ])>::value, "Supply a scalar of the vectors element filetype.");
		/*% endfor %*/
		/*% for idx in range(dim) %*/
		vec[ $idx@ ] = scalars[ $idx@ ];
		/*% endfor %*/
	}
	/*% endif %*/
	
	/// Set all vector components individually
	template <s::size_t _Dim>
	avl_ainl constexpr auto set_all($vecPar@& vec, const sc* scalars) noexcept -> void/*% if filetype=='h' %*/;
	/*% else %*/ {
		static_assert(_Dim>=$dim@, "Supply at least $dim@ scalars.");
		/*% for idx in range(dim) %*/
		static_assert(eq<decltype(vec[ $idx@ ]), decltype(scalars[ $idx@ ])>::value, "Supply a scalar of the vectors element type.");
		/*% endfor %*/
		/*% for idx in range(dim) %*/
		vec[ $idx@ ] = scalars[ $idx@ ];
		/*% endfor %*/
	}
	/*% endif %*/
	
$endSection()@
$section("General vector operations for "+dim|string+" component vectors")@
### Generate all permutations of the base operations: add_mk, add_set, add, sub_mk, ... , div_set, div
//% for op, s in [("add", "+"), ("sub", "-"), ("mul", "*"), ("div", "/")]
//%   if filetype=='test'
	$vecCreateRnd(op+"_var_1")@;
	$vecCreateRnd(op+"_var_2")@;
	$scalarCreateRnd(op+"_scalar")@;
	
	const $arrCreate(op+"_vec_res")@ =
		{ /*% call loop_(range(dim)) %*/get<#>($op@_var_1) $s@ get<#>($op@_var_2)/*% endcall %*/ };
	const $arrCreate(op+"_scalar_res")@ =
		{ /*% call loop_(range(dim)) %*/get<#>($op@_var_1) $s@ get<#>($op@_scalar)/*% endcall %*/ };
	const $arrCreate(op+"_vec_scalar_res")@ =
		{ /*% call loop_(range(dim)) %*/get<#>($op@_var_1) $s@ get<#>($op@_var_2) $s@ get<#>($op@_scalar)/*% endcall %*/ };
	
//%   endif
//% endfor
//% for op, s in [("add", "+"), ("sub", "-"), ("mul", "*"), ("div", "/")]
//%   for mut, rt in [('_mk', ''), ('_set', ' -> void'), ('', ' -> decltype(vec)')]
	
	//% call func([2,3,4], '//' + op + mut)
	avl_ainl_res constexpr auto $op+mut@(const $vecPar@& vec, const $vecPar@& other) noexcept$if_then(op=="div", '(ndebug|exude)')+rt@
	{
		//% call loop_if(op=="div", range(dim), '')
		assert(get<#>(other)!=decltype(other[#]){0});
		//% endcall
		
		//% if mut=="_mk"
		return rem_const_ref_t< decltype(vec) >
					{/*% call loop_(range(dim)) %*/get<#>(vec) $s@ get<#>(other)/*% endcall %*/ };
		//% elif mut=="_set"
		set_all(vec, /*% call loop_(range(dim)) %*/get<#>(vec) $s@ get<#>(other)/*% endcall %*/ );
		//% else
		set_all(vec, /*% call loop_(range(dim)) %*/get<#>(vec) $s@ get<#>(other)/*% endcall %*/ );
		return vec;
		//% endif
	}
	test_case
	{
		//% if mut=='_mk'
		auto res = $op+mut@($op@_var_1, $op@_var_2);
		//%   call loop_(range(dim), '')
		REQUIRE( get<#>(res) == Approx($op@_vec_res[#]) );
		//%   endcall
		REQUIRE( &res != &$op@_var_1 ); //result must be a new resource
		REQUIRE( &res != &$op@_var_2 ); //also different to $op@_var_2
		//% elif mut=='_set'
		$op+mut@($op@_var_1, $op@_var_2);
		//%   call loop_(range(dim), '')
		REQUIRE( get<#>(res) == Approx($op@_vec_res[#]) );
		//%   endcall
		//% else
		auto &res = $op+mut@($op@_var_1, $op@_var_2);
		//%   call loop_(range(dim), '')
		REQUIRE( get<#>(res) == Approx($op@_vec_res[#]) );
		//%   endcall
		REQUIRE( &res == &$op@_var_1 );//result must be $op@_var_1
		REQUIRE( &res != &$op@_var_2 );//but not $op@_var_2
		auto &res2 = $op+mut@(res, $op@_scalar);
		//%   call loop_(range(dim), '')
		REQUIRE( get<#>(res2) == Approx($op@_vec_sclar_res[#]) );
		//%   endcall
		REQUIRE( &res2 == &$op@_var_1 );//result must be $op@_var_1
		//% endif
	}
	//% endcall
	
	//% call func([2,3,4], '//' + op + mut +' (scalar)')
	avl_ainl_res constexpr auto $op+mut@(const $vecPar@& vec, const $scalarPar@ scalar) noexcept$if_then(op=="div", '(ndebug|exude)')+rt@
	{
		//% if op=="div"
		assert(scalar!=decltype(scalar){0});
		//% endif
		
		//% if mut=="_mk"
		return rem_const_ref_t< decltype(vec) >
					{/*% call loop_(range(dim)) %*/get<#>(vec) $s@ scalar/*% endcall %*/ };
		//% elif mut=="_set"
		set_all(vec, /*% call loop_(range(dim)) %*/get<#>(vec) $s@ scalar/*% endcall %*/ );
		//% else
		set_all(vec, /*% call loop_(range(dim)) %*/get<#>(vec) $s@ scalar/*% endcall %*/ );
		return vec;
		//% endif
	}
	test_case
	{
		//% if mut=='_mk'
		auto res = $op+mut@($op@_var_1, $op@_scalar);
		//%   call loop_(range(dim), '')
		REQUIRE( get<#>(res) == Approx($op@_scalar_res[#]) );
		//%   endcall
		REQUIRE( &res != &$op@_var_1 ); //result must be a new resource
		//% elif mut=='_set'
		$op+mut@($op@_var_1, $op@_scalar);
		//%   call loop_(range(dim), '')
		REQUIRE( get<#>(res) == Approx($op@_scalar_res[#]) );
		//%   endcall
		//% else
		auto &res = $op+mut@($op@_var_1, $op@_scalar);
		//%   call loop_(range(dim), '')
		REQUIRE( get<#>(res) == Approx($op@_scalar_res[#]) );
		//%   endcall
		REQUIRE( &res == &$op@_var_1 );//result must be $op@_var_1
		auto &res2 = $op+mut@(res, $op@_var_2);
		//%   call loop_(range(dim), '')
		REQUIRE( get<#>(res2) == Approx($op@_vec_scalar_res[#]) );
		//%   endcall
		REQUIRE( &res2 == &$op@_var_1 );//result must be $op@_var_1
		
		//% endif
	}
	//% endcall
	
//%   endfor
//% endfor
	
	/*% if dim==2 %*/
	/*% include 'v2.jin' %*/
	/*% elif dim==3 %*/
	/*% include 'v3.jin' %*/
	/*% else%*/
	/*% include 'v4.jin' %*/
	/*% endif %*/
	
$endSection()@
$section("Vector length operations for "+dim|string+" component vectors")@
	
	/// Calculate the square length of the vector
	avl_ainl_res constexpr auto len_sqr(const $vecPar@& vec) noexcept -> decltype(cmp(vec))/*% if filetype=='h' %*/;
	/*% else %*/ {
		/*% for idx in range(dim) %*/
		const auto cmp$idx@ = get<$idx@>(vec);
		/*% endfor %*/
		return $ h.cmp_wise_op("cmp? @ cmp?", "*", " + ", dim) @;
	}
	/*% endif %*/
	
$endSection()@
$section("Vector operations with scalar results for "+dim|string+" component vectors")@
	
	avl_ainl_res constexpr auto dot(const $vecPar@& vec, const $vecPar@& other) noexcept -> decltype(cmp(vec))/*% if filetype=='h' %*/;
	/*% else %*/ {
		return $ h.cmp_wise_op("get<?>(vec) @ get<?>(other)", "*", " + ", dim) @;
	}
	/*% endif %*/
	
$endSection()@

//% if filetype!='test'
}
#endif // AVL_$filename.upper()@_$filetype.upper()@
//%- endif
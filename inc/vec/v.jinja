###-
###- Import jinja helpers
###-
//%- from 'helpers.jin' import deg_to_rad with context
//%- from 'flow.jin' import loop_, loop_if, if_then, if_then_else with context
//%- from 'sequence.jin' import getRndInt, getRndFloat, getRndFloatPos, getRndFloatNeg with context
//%- from 'test.jin' import arrCreate, arrCreateRnd, arrCreateSeq, scalarType, scalarCreate, scalarCreateRnd with context
//%- from 'vec.jin' import vecReadCmp, vecWriteCmp, vecRetCmp, vecCreate, vecCreateRnd, vecCreateSeq, vecCreateZero with context
//%- from 'check.jin' import checkDim, checkCmpType with context
//%- from 'avl.jin' import func, section, endSection with context
###-
###- Define global strings so that they can be used like variables
###-
//%- set vec = 'vec'
//%- set unit_vec = 'unit_vec'
//%- set arr = 'arr'
//%- set _Idx = '_Idx'
//%- set idx = 'idx'
//%- set scalar = 'scalar'
//%- set supplyScalar = '"Supply a scalar of the vectors element type."'
//%- if filetype!="test"
#ifndef AVL_$filename.upper()@_$filetype.upper()@
#define AVL_$filename.upper()@_$filetype.upper()@

#pragma once

#include "../helper/const.h"

/// avl: A Vector Library
/// \author Thomas Pollak
namespace avl
$'{\n'@
//%- else
#include "../../ext/catch/catch.hpp"
#include "../../inc/avl.h"

using namespace avl;

//% endif
$section("Helper functions")@
	
	//% call func([0], "//Component type helper")
	avl_ainl_res constexpr auto cmp(const $vecPar@& vec) noexcept -> $vecRetCmp(vec)@
	{
		return $vecReadCmp(vec, 0)@;
	}
	test_case
	{
		const $vecCreate(vec)@;
		static_assert($checkCmpType(vec, 0, "cmp(vec)")@, $supplyScalar@);
	}
	//% endcall
	
$endSection()@
$section("Getters and setters for all vectors")@
	
	//% call func([0], "/// Access the vector components by a range checked index from 0 to dim-1")
	avl_ainl_res constexpr auto get($vecPar@& vec, const s::size_t idx) noexcept(ndebug||exuse) -> decltype(cmp(vec))
	{
		assert($checkDim(vec, idx)@);
		return $vecReadCmp(vec, idx)@;
	}
	test_case
	{
		const $vecCreateSeq(vec)@;
		
		//% for i in range(dim)
		REQUIRE( get(vec, $i@) == Approx( $i@ ) );
		//% endfor
	}
	//% endcall
	
	//% call func([0], "/// Access the vector components by a static range checked index from 0 to dim-1")
	template<s::size_t _Idx> avl_ainl_res constexpr auto get(const $vecPar@& vec) noexcept -> decltype(cmp(vec))
	{
		static_assert($checkDim(vec, _Idx)@, "Index is out of range");
		return $vecReadCmp(vec, _Idx)@;
	}
	test_case
	{
		const $vecCreateSeq(vec)@;
		
		//% for i in range(dim)
		REQUIRE( get<$i@>(vec) == Approx( $i@ ) );
		//% endfor
	}
	//% endcall
	
	//% call func([0], "/// Set a single component by index from 0 to dim-1")
	avl_ainl constexpr auto set($vecPar@& vec, const s::size_t idx, const $scalarPar@ scalar) noexcept(ndebug||exuse) -> void
	{
		static_assert($checkCmpType(vec, idx, scalar)@, $supplyScalar@);
		assert($checkDim(vec, idx)@);
		$vecWriteCmp(vec, idx, scalar)@;
	}
	test_case
	{
		$vecCreate(vec)@;
		const $arrCreateRnd(arr)@;
		
		//% for i in range(dim)
		set(vec, $i@, arr[$i@]);
		REQUIRE( get(vec, $i@) == Approx( arr[$i@] ) );
		//% endfor
	}
	//% endcall
	
	//% call func([0], "/// Set a single component by static index from 0 to dim-1")
	template<s::size_t _Idx> avl_ainl constexpr auto set($vecPar@& vec, const $scalarPar@ scalar) noexcept -> void
	{
		static_assert($checkCmpType(vec, _Idx, scalar)@, $supplyScalar@);
		static_assert($checkDim(vec, _Idx)@, "Index is out of range");
		$vecWriteCmp(vec, _Idx, scalar)@;
	}
	test_case
	{
		$vecCreateSeq(vec)@;
		const $arrCreateRnd(arr)@;
		
		//% for i in range(dim)
		set<$i@>(vec, arr[ $i@ ]);
		REQUIRE( get<$i@>(vec) == Approx( arr[$i@] ) );
		//% endfor
	}
	//% endcall
	
$endSection()@
$section("Dimension independent vector length operations")@
	
	//% call func([0], "/// Returns a new vector with the requested length")
	avl_ainl_res constexpr auto setlen_mk(const $vecPar@& vec, const $scalarPar@ len_to_set) noexcept(ndebug|exuse)
	{
		const auto vec_len = len(vec);
		assert(vec_len!=cnst<decltype(vec_len)>::zero);
		return mul_mk(vec, len_to_set / vec_len));
	}
	test_case
	{
		const $vecCreateRnd(vec)@;
		const auto len_to_set = $getRndFloat()@;
		const auto new_vec = setlen_mk(vec, len_to_set);
		const auto len_new_vec = len(new_vec);
		
		REQUIRE( len_new_vec == Approx(len_to_set) );
		
		//test edge case 0.0
		const auto zero_len_vec = setlen_mk(vec, cnst<$scalarType()@>::zero);
		//% for i in range(dim)
		REQUIRE( get<$i@>(zero_len_vec) == Approx( cnst<$scalarType()@>::zero ) );
		//% endfor
	}
	//% endcall

//%for mut, rt, res, info in [('_set', '-> void', '', ''), ('', '-> decltype(cmp(vec))', '_res', ' and return the same vector (chained)')]
	//% call func([0], "/// Set the length of the vector"+info)
	avl_ainl$res@ constexpr auto setlen$mut@($vecPar@& vec, const $scalarPar@ len_to_set) noexcept(ndebug|exuse) $rt@
	{
		const auto vec_len = len(vec);
		assert(vec_len!=cnst<decltype(vec_len)>::zero);
		mul_set(vec, len_to_set / vec_len);
		//% if mut==''
		return vec;
		//% endif
	}
	test_case
	{
		$vecCreateRnd(vec)@;
		const auto len_to_set = $getRndFloat()@;
		$if_then(mut=='', 'const auto ret_vec = ')@setlen$mut@(vec, len_to_set);
		const auto vec_len = len(vec);
		
		REQUIRE( vec_len == Approx(len_to_set) );
		
		//% if mut==''
		REQUIRE( &vec == &ret_vec);
		//% endif
		
		//test edge case 0.0
		$if_then(mut=='', 'const auto ret_zero_vec = ')@setlen$mut@(vec, cnst<$scalarType()@>::zero);
		
		//% for i in range(dim)
		REQUIRE( get<$i@>(vec) == Approx( cnst<$scalarType()@>::zero ) );
		//% endfor
		
		//% if mut==''
		REQUIRE( &vec == &ret_zero_vec);
		//% endif
	}
	//% endcall
//% endfor
	
	//% call func([0], "/// Calculate the length of the vector, prefere len_sqr when comparing distances")
	avl_ainl_res constexpr auto len(const $vecPar@& vec) noexcept -> decltype(cmp(vec))
	{
		//len_sqr will never return any negativ values so we can gurantee noexcept
		const auto vec_square_len = len_sqr(vec);
		return static_cast<decltype(cmp(vec))>( s::sqrt( vec_square_len ) );
	}
	test_case
	{
		const $vecCreateRnd(vec)@;
		const auto vec_len = len(vec);
		const auto vec_square_len = /*% call loop_(range(dim), ' + ') %*/get<#>(vec) * get<#>(vec)/*% endcall %*/;
		REQUIRE( vec_len == Approx( s::sqrt( vec_square_len ) ) );
		
		//test edge case 0.0
		const $vecCreateZero("zero_vec")@;
		const auto zero_vec_len = len(zero_vec);
		REQUIRE( zero_vec_len == Approx( cnst<$scalarType()@>::zero ) );
	}
	//% endcall
	
//%- set altParamDesc = ', use alternative vector if the current vector length is 0'
//% for zeroLenParam, ex, info in [('', '(ndebug||exuse)', ''), (', const '+vecPar+'& vec_if_zero_len', '', altParamDesc)]
	//% call func([0], "/// Returns a normalized vector" + info)
	avl_ainl_res constexpr auto norm_mk(const $vecPar@& vec $zeroLenParam@) noexcept$ex@ -> decltype(vec)
	{
		const auto vec_len = len(vec);
		//% if zeroLenParam!=''
		if(vec_len==cnst<decltype(vec_len)>::zero)
			return vec_if_zero_len;
		//% endif
		return div_mk(vec, vec_len); //div might assert in debug
	}
	//%   if zeroLenParam==''
	test_case
	{
		
		const $vecCreateRnd(vec)@;
		const auto new_norm_vec = norm_mk(vec);
		const auto norm_len = len(new_norm_vec);
		REQUIRE( norm_len == Approx( cnst<$scalarType()@>::one ) );
	}
	//%   else
	test_case
	{
		const $vecCreateZero("zero_vec")@;
		const auto zero_len = len(zero_vec)
		REQUIRE( zero_len == Approx( cnst<$scalarType()@>::zero ) );
		
		$vecCreateZero(unit_vec)@;
		set<0>(unit_vec, cnst<$scalarType()@>::one);
		
		const auto new_unit_vec = norm_mk(zero_vec, unit_vec);
		const auto new_unit_vec_len = len(new_unit_vec);
		REQUIRE( new_unit_vec_len == Approx( cnst<$scalarType()@>::one ) );
		REQUIRE( get<0>(new_unit_vec) == Approx( cnst<$scalarType()@>::one ) );
	}
	//%   endif
	//% endcall
//% endfor
	
//% for mut, rt, res, info1 in [('_set', '-> void', '', ''), ('', '-> decltype(cmp(vec))', '_res', ' and return the same vector (chained)')]
//%   for zeroLenParam, info2 in [('', ''), (', const '+vecPar+'& vec_if_zero_len', altParamDesc)]
	//% call func([0], "/// Normalize the current vector" + info1 + info2)
	avl_ainl$res@ constexpr auto norm$mut@(const $vecPar@& vec $zeroLenParam@) noexcept $rt@
	{
		const auto vec_len = len(vec);
		//% if zeroLenParam!=''
		if(vec_len==cnst<decltype(vec_len)>::zero)
		{
			set_all(vec, vec_if_zero_len);
			return;
		}
		//% endif
		div_set(vec, vec_len); //div might assert in debug
		//% if mut==''
		return vec;
		//% endif
	}
	//%   if zeroLenParam==''
	test_case
	{
		$vecCreateRnd(vec)@;
		$if_then(mut=='', 'auto ret_vec = ')@norm$mut@(vec);
		const auto len_to_set = len(vec);
		REQUIRE( len_to_set == Approx( cnst<$scalarType()@>::one ) );
		//% if mut==''
		REQUIRE( &vec == &ret_vec);
		//% endif
	}
	//%   else
	test_case
	{
		$vecCreateZero(vec)@;
		const auto zero_len = len(vec)
		REQUIRE( zero_len == Approx( cnst<$scalarType()@>::zero ) );
		
		$vecCreateZero(unit_vec)@;
		set<0>(unit_vec, cnst<$scalarType()@>::one);
		
		$if_then(mut=='', 'auto ret_vec = ')@norm$mut@(vec, unit_vec);
		const auto vec_len = len(vec);
		REQUIRE( vec_len == Approx( cnst<$scalarType()@>::one ) );
		REQUIRE( get<0>(vec) == Approx( cnst<$scalarType()@>::one ) );
		//% if mut==''
		REQUIRE( &vec == &ret_vec);
		//% endif
	}
	//%   endif
	//% endcall
//%   endfor
//% endfor
	
$endSection()@
$section("Dimension independent vector operations with scalar results")@
//% for mut, mul, info in [('_rd', '', 'radian'),('_dg', ' * cnst<decltype(cmp(vec))>::to_deg', 'degree')]
	//% call func([0],"/// Calculate the angle between two vectors in "+info)
	avl_ainl_res constexpr auto angle$mut@(const $vecPar@& vec, const $vecPar@& other) noexcept -> decltype(cmp(vec))
	{
		const auto vec_len		= len(vec);
		const auto other_len	= len(other);
		const auto dot_prod		= dot(vec, other);
		return s::acos( dot_prod / ( vec_len * other_len ) )$mul@;
	}
	test_case
	{
		const auto random_len1 = $getRndFloatPos()@;
		const auto random_len2 = $getRndFloatPos()@;
		const auto random_len3 = $getRndFloatPos()@;
		const auto random_len4 = $getRndFloatPos()@;
		
		$vecCreateZero("vec_zero")@;
		$vecCreateZero("vec_10x")@;
		set<0>(vec_10x, random_len1);
		$vecCreateZero("vec_01x")@;
		set<1>(vec_01x, random_len2);
		$vecCreateZero("vec_m10x")@;
		set<0>(vec_m10x, -random_len3);
		$vecCreateZero("vec_11x")@;
		set<0>(vec_11x, random_len4);
		set<1>(vec_11x, random_len4);
		
		const auto angle0 = angle$mut@(vec_10x, vec_zero);
		REQUIRE( angle0 == Approx( cnst<$scalarType()@>::zero );
		
		const auto angle90 = angle$mut@(vec_10x, vec_01x);
		REQUIRE( angle90 == Approx( $if_then_else(mut=='_rd', deg_to_rad(90), 90)@ );
		
		const auto angle45a = angle$mut@(vec_10x, vec_11x);
		REQUIRE( angle45a == Approx( $if_then_else(mut=='_rd', deg_to_rad(45), 45)@ );
		const auto angle45b = angle$mut@(vec_01x, vec_11x);
		REQUIRE( angle45b == Approx( $if_then_else(mut=='_rd', deg_to_rad(45), 45)@ );
		
		const auto angle135 = angle$mut@(vec_m10x, vec_11x);
		REQUIRE( angle135 == Approx( $if_then_else(mut=='_rd', deg_to_rad(135), 135)@ );
		
		const auto angle180 = angle$mut@(vec_10x, vec_m10x);
		REQUIRE( angle180 == Approx( $if_then_else(mut=='_rd', deg_to_rad(180), 180)@ );
	}
	//%   if dim>=3
	test_case
	{
		const auto random_len1 = $getRndFloatPos()@;
		const auto random_len2 = $getRndFloatPos()@;
		const auto random_len3 = $getRndFloatPos()@;
		const auto random_len4 = $getRndFloatPos()@;
		
		$vecCreateZero("vec_zero")@;
		$vecCreateZero("vec_010x")@;
		set<1>(vec_010x, random_len1);
		$vecCreateZero("vec_001x")@;
		set<2>(vec_001x, random_len2);
		$vecCreateZero("vec_0m10x")@;
		set<1>(vec_0m10x, -random_len3);
		$vecCreateZero("vec_011x")@;
		set<1>(vec_011x, random_len4);
		set<2>(vec_011x, random_len4);
		
		const auto angle0 = angle$mut@(vec_010x, vec_zero);
		REQUIRE( angle0 == Approx( cnst<$scalarType()@>::zero );
		
		const auto angle90 = angle$mut@(vec_010x, vec_001x);
		REQUIRE( angle90 == Approx( $if_then_else(mut=='_rd', deg_to_rad(90), 90)@ );
		
		const auto angle45a = angle$mut@(vec_010x, vec_011x);
		REQUIRE( angle45a == Approx( $if_then_else(mut=='_rd', deg_to_rad(45), 45)@ );
		const auto angle45b = angle$mut@(vec_001x, vec_011x);
		REQUIRE( angle45b == Approx( $if_then_else(mut=='_rd', deg_to_rad(45), 45)@ );
		
		const auto angle135 = angle$mut@(vec_0m10x, vec_011x);
		REQUIRE( angle135 == Approx( $if_then_else(mut=='_rd', deg_to_rad(135), 135)@ );
		
		const auto angle180 = angle$mut@(vec_010x, vec_0m10x);
		REQUIRE( angle180 == Approx( $if_then_else(mut=='_rd', deg_to_rad(180), 180)@ );
	}
	//%   endif
	//%   if dim>=4
	test_case
	{
		const auto random_len1 = $getRndFloatPos()@;
		const auto random_len2 = $getRndFloatPos()@;
		const auto random_len3 = $getRndFloatPos()@;
		const auto random_len4 = $getRndFloatPos()@;
		
		$vecCreateZero("vec_zero")@;
		$vecCreateZero("vec_0010")@;
		set<2>(vec_0010, random_len1);
		$vecCreateZero("vec_0001")@;
		set<3>(vec_0001, random_len2);
		$vecCreateZero("vec_00m10")@;
		set<2>(vec_00m10, -random_len3);
		$vecCreateZero("vec_0011")@;
		set<2>(vec_0011, random_len4);
		set<3>(vec_0011, random_len4);
		
		const auto angle0 = angle$mut@(vec_0010, vec_zero);
		REQUIRE( angle0 == Approx( cnst<$scalarType()@>::zero );
		
		const auto angle90 = angle$mut@(vec_0010, vec_001x);
		REQUIRE( angle90 == Approx( $if_then_else(mut=='_rd', deg_to_rad(90), 90)@ );
		
		const auto angle45a = angle$mut@(vec_0010, vec_011x);
		REQUIRE( angle45a == Approx( $if_then_else(mut=='_rd', deg_to_rad(45), 45)@ );
		const auto angle45b = angle$mut@(vec_0001, vec_011x);
		REQUIRE( angle45b == Approx( $if_then_else(mut=='_rd', deg_to_rad(45), 45)@ );
		
		const auto angle135 = angle$mut@(vec_00m10, vec_011x);
		REQUIRE( angle135 == Approx( $if_then_else(mut=='_rd', deg_to_rad(135), 135)@ );
		
		const auto angle180 = angle$mut@(vec_0010, vec_0m10x);
		REQUIRE( angle180 == Approx( $if_then_else(mut=='_rd', deg_to_rad(180), 180)@ );
	}
	//%   endif
	//% endcall
//% endfor
$endSection()@
//% if dim!=0
$section("Getter and setters for "+dim|string+" component vectors")@
	
	//% call func([2,3,4], '/// Set all vector components to the same scalar')
	avl_ainl constexpr auto set_all($vecPar@& vec, const $scalarPar@ scalar) noexcept -> void
	{
		static_assert(eq<decltype(vec[0]), decltype(scalar)>::value, "Supply a scalar of the vectors element filetype.");
		//% for i in range(dim)
		$vecWriteCmp(vec, i, scalar)@;
		//% endfor
	}
	test_case
	{
		$vecCreateZero(vec)@;
		
		const auto val = $getRndFloat()@;
		set_all(vec, val);
		
		//% for i in range(dim)
		REQUIRE( get<$i@>(vec)==val );
		//% endfor
	}
	//% endcall
	
	//% call func([2,3,4], '/// Set all vector components individually')
	avl_ainl constexpr auto set_all($vecPar@& vec/*% call loop_(param) %*/const $scalarPar@ #/*% endcall %*/) noexcept -> void;
	{
		//% for i in range(dim)
		static_assert(eq<decltype(vec[ $i@ ]), decltype($param[i]@)>::value, "Supply a scalar of the vectors element type for $param[i]@.");
		//% endfor
		
		//% for i in range(dim)
		$vecWriteCmp(vec, i, param[i])@;
		//% endfor
	}
	test_case
	{
		$vecCreateZero(vec)@;
		const $arrCreateRnd(arr)@;
		
		set_all(vec,/*% call loop_(range(dim)) %*/arr[#]/*% endcall %*/);
		
		//% for i in range(dim)
		REQUIRE( get<$i@>(vec)==arr[$i@] );
		//% endfor
	}
	//% endcall
	
	//% call func([2,3,4], '/// Set all vector components individually by a fixed size array')
	avl_ainl constexpr auto set_all($vecPar@& vec, const $scalarPar@ scalars[ $dim@ ]) noexcept -> void
	{
		//% for i in range(dim)
		static_assert(eq<decltype(vec[ $i@ ]), decltype(scalars[ $i@ ])>::value, "Supply a scalar of the vectors element filetype.");
		//% endfor
		
		//% for i in range(dim)
		$vecWriteCmp(vec, i, 'scalars[' + i|string + ']')@;
		//% endfor
	}
	test_case
	{
		$vecCreateZero(vec)@;
		const $arrCreateRnd(arr)@;
		
		set_all(vec, arr);
		
		//% for i in range(dim)
		REQUIRE( get<$i@>(vec)==arr[$i@] );
		//% endfor
	}
	//% endcall
	
	//% call func([2,3,4], '/// Set all vector components individually by an array')
	template <s::size_t _Dim> avl_ainl constexpr auto set_all($vecPar@& vec, const $scalarPar@* scalars) noexcept -> void
	{
		static_assert(_Dim>=$dim@, "Supply at least $dim@ scalars.");
		//% for i in range(dim)
		static_assert(eq<decltype(vec[ $i@ ]), decltype(scalars[ $i@ ])>::value, "Supply a scalar of the vectors element type.");
		//% endfor
		
		//% for i in range(dim)
		$vecWriteCmp(vec, i, 'scalars[' + i|string + ']')@;
		//% endfor
	}
	test_case
	{
		$vecCreateZero(vec)@;
		const $arrCreateRnd(arr)@;
		const auto* ptr_to_arr = arr;
		
		set_all<$dim@>(vec, ptr_to_arr);
		
		//% for i in range(dim)
		REQUIRE( get<$i@>(vec)==arr[$i@] );
		//% endfor
	}
	//% endcall
	
$endSection()@
//% endif
$section("General vector operations for "+dim|string+" component vectors")@
### Generate all permutations of the base operations: add_mk, add_set, add, sub_mk, ... , div_set, div
//% for op, s in [("add", "+"), ("sub", "-"), ("mul", "*"), ("div", "/")]
//%   if filetype=='test'
	$vecCreateRnd(op+"_var_1")@;
	$vecCreateRnd(op+"_var_2")@;
	$scalarCreateRnd(op+"_scalar")@;
	
	const $arrCreate(op+"_vec_res")@ =
		{ /*% call loop_(range(dim)) %*/get<#>($op@_var_1) $s@ get<#>($op@_var_2)/*% endcall %*/ };
	const $arrCreate(op+"_scalar_res")@ =
		{ /*% call loop_(range(dim)) %*/get<#>($op@_var_1) $s@ get<#>($op@_scalar)/*% endcall %*/ };
	const $arrCreate(op+"_vec_scalar_res")@ =
		{ /*% call loop_(range(dim)) %*/get<#>($op@_var_1) $s@ get<#>($op@_var_2) $s@ get<#>($op@_scalar)/*% endcall %*/ };
	
//%   endif
//% endfor
//% for op, s in [("add", "+"), ("sub", "-"), ("mul", "*"), ("div", "/")]
//%   for mut, rt in [('_mk', ''), ('_set', ' -> void'), ('', ' -> decltype(vec)')]
	
	//% call func([2,3,4], '//' + op + mut)
	avl_ainl_res constexpr auto $op+mut@(const $vecPar@& vec, const $vecPar@& other) noexcept$if_then(op=="div", '(ndebug|exude)')+rt@
	{
		//% call loop_if(op=="div", range(dim), '')
		assert(get<#>(other)!=decltype(other[#]){0});
		//% endcall
		
		//% if mut=="_mk"
		return rem_const_ref_t< decltype(vec) >
					{/*% call loop_(range(dim)) %*/get<#>(vec) $s@ get<#>(other)/*% endcall %*/ };
		//% elif mut=="_set"
		set_all(vec, /*% call loop_(range(dim)) %*/get<#>(vec) $s@ get<#>(other)/*% endcall %*/ );
		//% else
		set_all(vec, /*% call loop_(range(dim)) %*/get<#>(vec) $s@ get<#>(other)/*% endcall %*/ );
		return vec;
		//% endif
	}
	//%   if mut=='_mk'
	test_case
	{
		auto res = $op+mut@($op@_var_1, $op@_var_2);
		//% call loop_(range(dim), '')
		REQUIRE( get<#>(res) == Approx($op@_vec_res[#]) );
		//% endcall
		REQUIRE( &res != &$op@_var_1 ); //result must be a new resource
		REQUIRE( &res != &$op@_var_2 ); //also different to $op@_var_2
		//% elif mut=='_set'
		$op+mut@($op@_var_1, $op@_var_2);
		//% call loop_(range(dim), '')
		REQUIRE( get<#>(res) == Approx($op@_vec_res[#]) );
		//% endcall
	}
	//%   else
	test_case
	{
		auto &res = $op+mut@($op@_var_1, $op@_var_2);
		//% call loop_(range(dim), '')
		REQUIRE( get<#>(res) == Approx($op@_vec_res[#]) );
		//% endcall
		REQUIRE( &res == &$op@_var_1 );//result must be $op@_var_1
		REQUIRE( &res != &$op@_var_2 );//but not $op@_var_2
		auto &res2 = $op+mut@(res, $op@_scalar);
		//% call loop_(range(dim), '')
		REQUIRE( get<#>(res2) == Approx($op@_vec_sclar_res[#]) );
		//% endcall
		REQUIRE( &res2 == &$op@_var_1 );//result must be $op@_var_1
	}
	//%   endif
	//% endcall
	
	//% call func([2,3,4], '//' + op + mut +' (scalar)')
	avl_ainl_res constexpr auto $op+mut@(const $vecPar@& vec, const $scalarPar@ scalar) noexcept$if_then(op=="div", '(ndebug|exude)')+rt@
	{
		//% if op=="div"
		assert(scalar!=cnst<decltype(scalar)>::zero);
		//% endif
		
		//% if mut=="_mk"
		return rem_const_ref_t< decltype(vec) >
					{/*% call loop_(range(dim)) %*/get<#>(vec) $s@ scalar/*% endcall %*/ };
		//% elif mut=="_set"
		set_all(vec, /*% call loop_(range(dim)) %*/get<#>(vec) $s@ scalar/*% endcall %*/ );
		//% else
		set_all(vec, /*% call loop_(range(dim)) %*/get<#>(vec) $s@ scalar/*% endcall %*/ );
		return vec;
		//% endif
	}
	//%   if mut=='_mk'
	test_case
	{
		auto res = $op+mut@($op@_var_1, $op@_scalar);
		//% call loop_(range(dim), '')
		REQUIRE( get<#>(res) == Approx($op@_scalar_res[#]) );
		//% endcall
		REQUIRE( &res != &$op@_var_1 ); //result must be a new resource
	}
	//%   elif mut=='_set'
	test_case
	{
		$op+mut@($op@_var_1, $op@_scalar);
		//% call loop_(range(dim), '')
		REQUIRE( get<#>(res) == Approx($op@_scalar_res[#]) );
		//% endcall
	}
	//%   else
	test_case
	{
		auto &res = $op+mut@($op@_var_1, $op@_scalar);
		//% call loop_(range(dim), '')
		REQUIRE( get<#>(res) == Approx($op@_scalar_res[#]) );
		//% endcall
		REQUIRE( &res == &$op@_var_1 );//result must be $op@_var_1
		auto &res2 = $op+mut@(res, $op@_var_2);
		//% call loop_(range(dim), '')
		REQUIRE( get<#>(res2) == Approx($op@_vec_scalar_res[#]) );
		//% endcall
		REQUIRE( &res2 == &$op@_var_1 );//result must be $op@_var_1
	}
	//%   endif
	//% endcall
	
//%   endfor
//% endfor
	
	/*% if dim==2 %*/
	/*% include 'v2.jin' %*/
	/*% elif dim==3 %*/
	/*% include 'v3.jin' %*/
	/*% else%*/
	/*% include 'v4.jin' %*/
	/*% endif %*/
	
$endSection()@
$section("Vector length operations for "+dim|string+" component vectors")@
	
	/// Calculate the square length of the vector
	avl_ainl_res constexpr auto len_sqr(const $vecPar@& vec) noexcept -> decltype(cmp(vec))/*% if filetype=='h' %*/;
	/*% else %*/ {
		/*% for i in range(dim) %*/
		const auto cmp$i@ = get<$i@>(vec);
		/*% endfor %*/
		return /*% call loop_(range(dim), ' + ') %*/ cmp#*cmp# /*% endcall %*/;
	}
	/*% endif %*/
	
$endSection()@
$section("Vector operations with scalar results for "+dim|string+" component vectors")@
	
	avl_ainl_res constexpr auto dot(const $vecPar@& vec, const $vecPar@& other) noexcept -> decltype(cmp(vec))/*% if filetype=='h' %*/;
	/*% else %*/ {
		return /*% call loop_(range(dim), ' + ') %*/ get<#>(vec) * get<#>(other) /*% endcall %*/;
	}
	/*% endif %*/
	
$endSection()@

//% if filetype!='test'
}
#endif // AVL_$filename.upper()@_$filetype.upper()@
//%- endif
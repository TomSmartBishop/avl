#include "../../ext/catch/catch.hpp"

#include "../../inc/avl.h"
{% import 'helpers.jin' as h %}

using namespace avl;

TEST_CASE( "Setters and getters for {{name}}({{dim}})", "[{{name}}({{dim}})]" ) {
	{{name}} var{{extends}};
	const {{type}} set_to[{{dim}}] = { {% for idx in range(dim) %}{% if not loop.first %}, {% endif %}{{idx}}.{{9-idx}}{{suffix}} {% endfor %} };
	
	SECTION("set all components") {
		const {{type}} all = -{{dim}}.5{{suffix}};
		set_all( var, all);
		
		{% for idx in range(dim) %}
		REQUIRE( var[{{idx}}] == all );
		{% endfor %}
	}
	
	SECTION("set all components via fixed array") {
		set_all( var, set_to);
		
		{% for idx in range(dim) %}
		REQUIRE( var[{{idx}}] == set_to[{{idx}}] );
		{% endfor %}
	}
	
	SECTION("set all components via array") {
		set_all<{{dim}}>(var, static_cast<const {{type}}*>(set_to));
		
		{% for idx in range(dim) %}
		REQUIRE( var[{{idx}}] == set_to[{{idx}}] );
		{% endfor %}
	}
	
	SECTION("set all components individually") {
		set_all(var, {{h.cmp_wise_op("set_to[?] ", "", ",", dim)}});
		
		{% for idx in range(dim) %}
		REQUIRE( var[{{idx}}] == set_to[{{idx}}] );
		{% endfor %}
	}
	
	SECTION("set/get component") {
		{% for idx in range(dim) %}
		set(var, {{idx}}, set_to[{{idx}}] );
		
		REQUIRE( var[{{idx}}] == set_to[{{idx}}] );
		REQUIRE( get(var, {{idx}}) == set_to[{{idx}}] );
		{% endfor %}
	}
	
	SECTION("set/get component (static)") {
		{% for idx in range(dim) %}
		set<{{idx}}>(var, set_to[{{idx}}] );
		
		REQUIRE( var[{{idx}}] == set_to[{{idx}}] );
		REQUIRE( get<{{idx}}>(var) == set_to[{{idx}}] );
		{% endfor %}
	}
}

{% for op_name, op in [("add", "+"), ("sub", "-"), ("mul", "*"), ("div", "/")] %}

TEST_CASE( "{{op_name.capitalize()}} operation for {{name}}({{dim}})", "[{{name}}({{dim}})]" ) {
	{{name}} var_1{{extends}} = { {% for idx in range(dim) %}{% if not loop.first %}, {% endif %}{{idx}}.{{9-idx}}{{suffix}} {% endfor %} };
	{{name}} var_2{{extends}} = { {% for idx in range(dim) %}{% if not loop.first %}, {% endif %}{{9-idx}}.{{idx}}{{suffix}} {% endfor %} };
	//let the compiler evaluate the result
	const {{type}} expt_res_1[{{dim}}] = { {% for idx in range(dim) %}{% if not loop.first %}, {% endif %}{{idx}}.{{9-idx}}{{suffix}} {{op}} {{9-idx}}.{{idx}}{{suffix}} {% endfor %} };
	
	const {{type}} scalar = {{dim}}.1{{suffix}};
	const {{type}} expt_res_2[{{dim}}] = { {% for idx in range(dim) %}{% if not loop.first %}, {% endif %}{{idx}}.{{9-idx}}{{suffix}} {{op}} {{dim}}.1{{suffix}} {% endfor %} };
	
	const {{type}} expt_res_3[{{dim}}] = { {% for idx in range(dim) %}{% if not loop.first %}, {% endif %}{{idx}}.{{9-idx}}{{suffix}} {{op}} {{9-idx}}.{{idx}}{{suffix}} {{op}} {{dim}}.1{{suffix}} {% endfor %} };
	
	{% if test_type=='Vector' %}
	SECTION("{{op_name}} make {{test_type.lower()}}") {
		auto res = {{op_name}}_mk(var_1, var_2);
		
		{% for idx in range(dim) %}
		REQUIRE( res[{{idx}}] == Approx(expt_res_1[{{idx}}]) );
		{% endfor %}
		
		//we don't wont to point accidentally to the same memory location
		REQUIRE( &res != &var_1 );
		REQUIRE( &res != &var_2 );
	}
	
	SECTION("{{op_name}} make scalar") {
		auto res = {{op_name}}_mk(var_1, scalar);
		
		{% for idx in range(dim) %}
		REQUIRE( res[{{idx}}] == Approx(expt_res_2[{{idx}}]) );
		{% endfor %}
		
		//we don't wont to point accidentally to the same memory location
		REQUIRE( &res != &var_1 );
	}
	{% endif %}
	
	SECTION("{{op_name}} set {{test_type.lower()}}") {
		{{op_name}}_set(var_1, var_2);
		
		{% for idx in range(dim) %}
		REQUIRE( var_1[{{idx}}] == Approx(expt_res_1[{{idx}}]) );
		{% endfor %}
	}
	
	SECTION("{{op_name}} set scalar") {
		{{op_name}}_set(var_1, scalar);
		
		{% for idx in range(dim) %}
		REQUIRE( var_1[{{idx}}] == Approx(expt_res_2[{{idx}}]) );
		{% endfor %}
	}
	
	SECTION("{{op_name}} (chained) {{test_type.lower()}}") {
		auto &ref_to_1 = {{op_name}}(var_1, var_2);
		
		{% for idx in range(dim) %}
		REQUIRE( var_1[{{idx}}] == Approx(expt_res_1[{{idx}}]) );
		REQUIRE( var_1[{{idx}}] == Approx(ref_to_1[{{idx}}]) );
		{% endfor %}
		
		//must be the same memory location
		REQUIRE( &ref_to_1 == &var_1 );
		//and different here
		REQUIRE( &ref_to_1 != &var_2 );
	}
	
	SECTION("{{op_name}} (chained) scalar") {
		auto &ref_to_1 = {{op_name}}(var_1, scalar);
		
		{% for idx in range(dim) %}
		REQUIRE( var_1[{{idx}}] == Approx(expt_res_2[{{idx}}]) );
		REQUIRE( var_1[{{idx}}] == Approx(ref_to_1[{{idx}}]) );
		{% endfor %}
		
		//must be the same memory location
		REQUIRE( &ref_to_1 == &var_1 );
	}
	
	SECTION("{{op_name}} (chained) {{test_type.lower()}} and scalar") {
		auto &ref_to_1 = {{op_name}}({{op_name}}(var_1, var_2), scalar);
		
		{% for idx in range(dim) %}
		REQUIRE( var_1[{{idx}}] == Approx(expt_res_3[{{idx}}]) );
		{% endfor %}
		
		//must be the same memory location
		REQUIRE( &ref_to_1 == &var_1 );
		//and different here
		REQUIRE( &ref_to_1 != &var_2 );
	}
}

{% endfor %}

TEST_CASE( "Length operations for {{name}}({{dim}})", "[{{name}}({{dim}})]" ) {
	{{name}} var{{extends}} = { {% for idx in range(dim) %}{% if not loop.first %}, {% endif %}{{idx}}.{{9-idx}}{{suffix}} {% endfor %} };
	const {{type}} sqr = {% for idx in range(dim) %}{% if not loop.first %} + {% endif %}({{idx}}.{{9-idx}}{{suffix}} * {{idx}}.{{9-idx}}{{suffix}}){% endfor %};
	
	SECTION("get length") {
		auto res = len(var);
		
		REQUIRE( res*res == Approx(sqr) );
	}
	
	SECTION("get square length") {
		auto res = len_sqr(var);
		
		REQUIRE( res == Approx(sqr) );
	}
	
	{% if test_type=='Vector' %}
	SECTION("make new vector of length") {
		auto len_vec = len_mk(var, 9.9{{suffix}});
		auto res = len(len_vec);
		
		REQUIRE( res == Approx(9.9{{suffix}}) );
	}
	{% endif %}
	
	SECTION("set length") {
		len_set(var, 6.5{{suffix}});
		auto res = len(var);
		
		REQUIRE( res == Approx(6.5{{suffix}}) );
	}
}
//% call section('Vector length operations')
	
	//% call func('/// Returns a new vector with the requested length', match([2,3,4]), true)
	$dim_tpl(dim)@avl_ainl_res constexpr auto setlen_mk(const $vecPar@& vec, const $scalarPar@ len_to_set) noexcept(ndebug||exuse)
	{
		//% if dim!=2
		static_assert(_Dim>=-$dim@ && _Dim<=-2 && _Dim<=$dim@ && _Dim>=2 , "Provide a valid dimension parameter [$dim@,$dim@], excluding [-1,1] or remove the template parameter");
		//% endif
		const auto vec_len = len$if_then(dim!=2,'<_Dim>')@(vec);
		assert(vec_len!=cnst<decltype(vec_len)>::zero);
		return mul_mk$if_then(dim!=2,'<_Dim>')@(vec, len_to_set / vec_len);
	}
	test_case
	{
		//% for dimIdx in range(-dim+1, dim+1)
		//%   if dimIdx<-1 or dimIdx>1
		{
			const $vecCreateRnd(vec)@;
			const $scalarCreateRndPos('len_to_set')@;
			const auto new_vec = setlen_mk$dim_tpl_param(dim, dimIdx)@(vec, len_to_set);
			const auto len_new_vec = len$dim_tpl_param(dim, dimIdx)@(new_vec);
			
			REQUIRE( len_new_vec == Approx(len_to_set) );
			
			//test edge case 0.0
			const auto zero_len_vec = setlen_mk$dim_tpl_param(dim, dimIdx)@(vec, cnst<$scalarType()@>::zero);
			//% set r = range(dimIdx)
			/*% if dimIdx<0 %*/ /*% set r = range(dim + dimIdx, dim) %*/ /*% endif %*/
			//% for i in r
			REQUIRE( get<$i@>(zero_len_vec) == Approx( cnst<$scalarType()@>::zero ) );
			//% endfor
		}
		//%   endif
		//% endfor
	}
	//% endcall

//%for mut, rt, res, info in [('_set', '-> void', '', ''), ('', '-> decltype(vec)', '_res', ' and return the same vector (chained)')]
	//% call func('/// Set the length of the vector'+info, match([2,3,4]), true)
	$dim_tpl(dim)@avl_ainl$res@ constexpr auto setlen$mut@($vecPar@& vec, const $scalarPar@ len_to_set) noexcept(ndebug||exuse) $rt@
	{
		//% if dim!=2
		static_assert(_Dim>=-$dim@ && _Dim<=-2 && _Dim<=$dim@ && _Dim>=2 , "Provide a valid dimension parameter [$dim@,$dim@], excluding [-1,1] or remove the template parameter");
		//% endif
		const auto vec_len = len$if_then(dim!=2,'<_Dim>')@(vec);
		assert(vec_len!=cnst<decltype(vec_len)>::zero);
		mul_set$if_then(dim!=2,'<_Dim>')@(vec, len_to_set / vec_len);

		//% if mut==''
		return vec;
		//% endif
	}
	test_case
	{
		//% for dimIdx in range(-dim+1, dim+1)
		//%   if dimIdx<-1 or dimIdx>1
		{
			$vecCreateRnd(vec)@;
			const $scalarCreateRndPos('len_to_set')@;
			$if_then(mut=='', 'const auto &ret_vec = ')@setlen$mut@(vec, len_to_set);
			const auto vec_len = len$dim_tpl_param(dim, dimIdx)@(vec);
			
			REQUIRE( vec_len == Approx(len_to_set) );
			
			//% if mut==''
			REQUIRE( &vec == &ret_vec);
			//% endif
			
			//test edge case 0.0
			$if_then(mut=='', 'const auto &ret_zero_vec = ')@setlen$mut@$dim_tpl_param(dim, dimIdx)@(vec, cnst<$scalarType()@>::zero);
			
			//% set r = range(dimIdx)
			/*% if dimIdx<0 %*/ /*% set r = range(dim + dimIdx, dim) %*/ /*% endif %*/
			//% for i in r
			REQUIRE( get<$i@>(vec) == Approx( cnst<$scalarType()@>::zero ) );
			//% endfor
			
			//% if mut==''
			REQUIRE( &vec == &ret_zero_vec);
			//% endif
		}
		//%   endif
		//% endfor
	}
	//% endcall
//% endfor
	
	//% call func('/// Calculate the length of the vector, prefere len_sqr when comparing distances', match([2,3,4]), true)
	$dim_tpl(dim)@avl_ainl_res constexpr auto len(const $vecPar@& vec) noexcept -> decltype(cmp(vec))
	{
		//% if dim!=2
		static_assert(_Dim>=-$dim@ && _Dim<=-2 && _Dim<=$dim@ && _Dim>=2 , "Provide a valid dimension parameter [$dim@,$dim@], excluding [-1,1] or remove the template parameter");
		//% endif
		//len_sqr will never return any negativ values so we can gurantee noexcept
		const auto vec_square_len = len_sqr$if_then(dim!=2,'<_Dim>')@(vec);
		return static_cast<decltype(cmp(vec))>( s::sqrt( vec_square_len ) );
	}
	test_case
	{
		//% for dimIdx in range(-dim+1, dim+1)
		//%   if dimIdx<-1 or dimIdx>1
		{
			const $vecCreateRnd(vec)@;
			const auto vec_len = len$dim_tpl_param(dim, dimIdx)@(vec);
			//% if dimIdx<0
			const auto vec_square_len = /*% call loop_(range(dimIdx, 0), ' + ') %*/get<#>(vec) * get<#>(vec)/*% endcall %*/;
			//% else
			const auto vec_square_len = /*% call loop_(range(dimIdx), ' + ') %*/get<#>(vec) * get<#>(vec)/*% endcall %*/;
			//% endif
			REQUIRE( vec_len == Approx( s::sqrt( vec_square_len ) ) );
			
			//test edge case 0.0
			const $vecCreateZero('zero_vec')@;
			const auto zero_vec_len = len$dim_tpl_param(dim, dimIdx)@(zero_vec);
			REQUIRE( zero_vec_len == Approx( cnst<$scalarType()@>::zero ) );
		}
		//%   endif
		//% endfor
	}
	//% endcall
	
	//% call func('/// Calculate the square length of the vector', match([2,3,4]))
	$dim_tpl(dim)@avl_ainl_res constexpr auto len_sqr(const $vecPar@& vec) noexcept -> decltype(cmp(vec))
	{
		//% if dim!=2
		static_assert(_Dim>=-$dim@ && _Dim<=-2 && _Dim<=$dim@ && _Dim>=2 , "Provide a valid dimension parameter [$dim@,$dim@], excluding [-1,1] or remove the template parameter");
		//% endif
		/*% call all_dim(dim, '	return ', ';', ' + ') %*/get<#>(vec)*get<#>(vec)/*% endcall %*/
	}
	test_case
	{
		//% for dimIdx in range(-dim+1, dim+1)
		//%   if dimIdx<-1 or dimIdx>1
		{
			const $vecCreateRnd(vec)@;
			const auto vec_len_sqr = len_sqr$dim_tpl_param(dim, dimIdx)@(vec);
			//% if dimIdx<0
			const auto vec_len_sqr_check = /*% call loop_(range(dimIdx, 0), ' + ') %*/get<#>(vec) * get<#>(vec)/*% endcall %*/;
			//% else
			const auto vec_len_sqr_check = /*% call loop_(range(dimIdx), ' + ') %*/get<#>(vec) * get<#>(vec)/*% endcall %*/;
			//% endif
			REQUIRE( vec_len_sqr == Approx( vec_len_sqr_check ) );
			
			//test edge case 0.0
			const $vecCreateZero('zero_vec')@;
			const auto zero_vec_len_sqr = len_sqr$dim_tpl_param(dim, dimIdx)@(zero_vec);
			REQUIRE( zero_vec_len_sqr == Approx( cnst<$scalarType()@>::zero ) );
		}
		//%   endif
		//% endfor
	}
	//% endcall
	
//%- set altParamDesc = ', use alternative vector if the current vector length is 0'
//% for zeroLenParam, ex, info in [('', '(ndebug||exuse)', ''), (', const '+vecPar+'& vec_if_zero_len', '', altParamDesc)]
	//% call func('/// Returns a normalized vector' + info, match([2,3,4]), true)
	$dim_tpl(dim)@avl_ainl_res constexpr auto norm_mk(const $vecPar@& vec $zeroLenParam@) noexcept$ex@
	{
		//% if dim!=2
		static_assert(_Dim>=-$dim@ && _Dim<=-2 && _Dim<=$dim@ && _Dim>=2 , "Provide a valid dimension parameter [$dim@,$dim@], excluding [-1,1] or remove the template parameter");
		//% endif
		const auto vec_len = len$if_then(dim!=2,'<_Dim>')@(vec);
		//% if zeroLenParam!=''
		if(vec_len==cnst<decltype(vec_len)>::zero)
			return vec_if_zero_len;
		//% endif
		return div_mk$if_then(dim!=2,'<_Dim>')@(vec, vec_len); //div might assert in debug
	}
	//%   if zeroLenParam==''
	test_case
	{
		//% for dimIdx in range(-dim+1, dim+1)
		//%   if dimIdx<-1 or dimIdx>1
		const $vecCreateRnd(vec)@;
		const auto new_norm_vec = norm_mk$dim_tpl_param(dim, dimIdx)@(vec);
		const auto norm_len = len$dim_tpl_param(dim, dimIdx)@(new_norm_vec);
		REQUIRE( norm_len == Approx( cnst<$scalarType()@>::one ) );
		//%   endif
		//% endfor
	}
	//%   else
	test_case
	{
		//% for dimIdx in range(-dim+1, dim+1)
		//%   if dimIdx<-1 or dimIdx>1
		const $vecCreateZero('zero_vec')@;
		const auto zero_len = len$dim_tpl_param(dim, dimIdx)@(zero_vec);
		REQUIRE( zero_len == Approx( cnst<$scalarType()@>::zero ) );
		
		$vecCreateZero(unit_vec)@;
		set<0>(unit_vec, cnst<$scalarType()@>::one);
		
		const auto new_unit_vec = norm_mk$dim_tpl_param(dim, dimIdx)@(zero_vec, unit_vec);
		const auto new_unit_vec_len = len$dim_tpl_param(dim, dimIdx)@(new_unit_vec);
		REQUIRE( new_unit_vec_len == Approx( cnst<$scalarType()@>::one ) );
		REQUIRE( get<0>(new_unit_vec) == Approx( cnst<$scalarType()@>::one ) );
		//%   endif
		//% endfor
	}
	//%   endif
	//% endcall
//% endfor
	
//% for mut, rt, res, info1 in [('_set', '-> void', '', ''), ('', '-> decltype(vec)', '_res', ' and return the same vector (chained)')]
//%   for zeroLenParam, info2 in [('', ''), (', const '+vecPar+'& vec_if_zero_len', altParamDesc)]
	//% call func('/// Normalize the current vector' + info1 + info2, match([2,3,4]), true)
	$dim_tpl(dim)@avl_ainl$res@ constexpr auto norm$mut@($vecPar@& vec $zeroLenParam@) noexcept $rt@
	{
		//% if dim!=2
		static_assert(_Dim>=-$dim@ && _Dim<=-2 && _Dim<=$dim@ && _Dim>=2 , "Provide a valid dimension parameter [$dim@,$dim@], excluding [-1,1] or remove the template parameter");
		//% endif
		const auto vec_len = len$if_then(dim!=2,'<_Dim>')@(vec);
		//% if zeroLenParam!=''
		if(vec_len==cnst<decltype(vec_len)>::zero)
		{
			vec = vec_if_zero_len;
			//% if mut==''
			return vec;
			//% else
			return;
			//% endif
		}
		//% endif
		div_set$if_then(dim!=2,'<_Dim>')@(vec, vec_len); //div might assert in debug
		//% if mut==''
		return vec;
		//% endif
	}
	//%   if zeroLenParam==''
	test_case
	{
		//% for dimIdx in range(-dim+1, dim+1)
		//%   if dimIdx<-1 or dimIdx>1
		$vecCreateRnd(vec)@;
		$if_then(mut=='', 'const auto &ret_vec = ')@norm$mut@$dim_tpl_param(dim, dimIdx)@(vec);
		const auto len_of_norm_vec = len$dim_tpl_param(dim, dimIdx)@(vec);
		REQUIRE( len_of_norm_vec == Approx( cnst<$scalarType()@>::one ) );
		//%     if mut==''
		REQUIRE( &vec == &ret_vec);
		//%     endif
		//%   endif
		//% endfor
	}
	//%   else
	test_case
	{
		//% for dimIdx in range(-dim+1, dim+1)
		//%   if dimIdx<-1 or dimIdx>1
		$vecCreateZero(vec)@;
		const auto zero_len = len$dim_tpl_param(dim, dimIdx)@(vec);
		REQUIRE( zero_len == Approx( cnst<$scalarType()@>::zero ) );
		
		$vecCreateZero(unit_vec)@;
		set<0>(unit_vec, cnst<$scalarType()@>::one);
		
		$if_then(mut=='', 'const auto &ret_vec = ')@norm$mut@$dim_tpl_param(dim, dimIdx)@(vec, unit_vec);
		const auto vec_len = len$dim_tpl_param(dim, dimIdx)@(vec);
		REQUIRE( vec_len == Approx( cnst<$scalarType()@>::one ) );
		REQUIRE( get<0>(vec) == Approx( cnst<$scalarType()@>::one ) );
		//%     if mut==''
		REQUIRE( &vec == &ret_vec);
		//%     endif
		//%   endif
		//% endfor
	}
	//%   endif
	//% endcall
//%   endfor
//% endfor
	
//% endcall
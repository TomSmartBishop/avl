###-
###- Import jinja helpers
###-
//%- from 'helpers.jin' import deg_to_rad with context
//%- from 'flow.jin' import loop_, loop_if, if_then, if_then_else with context
//%- from 'sequence.jin' import getRndInt, getRndFloat, getRndFloatPos, getRndFloatNeg with context
//%- from 'test.jin' import arrCreate, arrCreateRnd, arrCreateSeq with context
//%- from 'test.jin' import scalarType, scalarCreate, scalarCreateRnd, scalarCreateRndPos, scalarCreateRndNeg with context
//%- from 'vec.jin' import vecReadCmp, vecWriteCmp, vecRetCmp, vecCreate, vecCreateRnd, vecCreateSeq, vecCreateZero with context
//%- from 'check.jin' import checkDim, checkCmpType with context
//%- from 'avl.jin' import func, section, match with context
###-
###- Define global strings so that they can be used like variables
###-
//%- set vec = 'vec'
//%- set unit_vec = 'unit_vec'
//%- set arr = 'arr'
//%- set _Idx = '_Idx'
//%- set idx = 'idx'
//%- set scalar = 'scalar'
//%- set supplyScalar = '"Supply a scalar of the vectors element type."'
//%- if filetype!='test'
#ifndef AVL_$filename.upper()@_$filetype.upper()@
#define AVL_$filename.upper()@_$filetype.upper()@

#pragma once

/// avl: A Vector Library
/// \author Thomas Pollak
namespace avl
$'{\n'@
//%- else
#include "../../ext/catch/catch.hpp"
#include "../../inc/avl.h"

using namespace avl;

//% endif
//% call section('Helper functions', match([0]), true)
	
	//% call func('//Component type helper', match([0]), true)
	avl_ainl_res constexpr auto cmp(const $vecPar@& vec) noexcept -> $vecRetCmp(vec)@
	{
		return $vecReadCmp(vec, 0)@;
	}
	test_case
	{
		const $vecCreateZero(vec)@;
		static_assert($checkCmpType(vec, 0, 'cmp(vec)')@, $supplyScalar@);
	}
	//% endcall
	
//% endcall
//% call section('Getters and setters for all vectors', match([0]), true)
	
	//% call func('/// Access the vector components by a range checked index from 0 to dim-1', match([0]), true)
	avl_ainl_res constexpr auto get(const $vecPar@& vec, const s::size_t idx) noexcept(ndebug||exuse) -> decltype(cmp(vec))
	{
		assert($checkDim(vec, idx)@);
		return $vecReadCmp(vec, idx)@;
	}
	test_case
	{
		const $vecCreateSeq(vec)@;
		
		//% for i in range(dim)
		REQUIRE( get(vec, $i@) == Approx( $i@ ) );
		//% endfor
	}
	//% endcall
	
	//% call func('/// Access the vector components by a static range checked index from 0 to dim-1', match([0]), true)
	template<s::size_t _Idx> avl_ainl_res constexpr auto get(const $vecPar@& vec) noexcept -> decltype(cmp(vec))
	{
		static_assert($checkDim(vec, _Idx)@, "Index is out of range");
		return $vecReadCmp(vec, _Idx)@;
	}
	test_case
	{
		const $vecCreateSeq(vec)@;
		
		//% for i in range(dim)
		REQUIRE( get<$i@>(vec) == Approx( $i@ ) );
		//% endfor
	}
	//% endcall
	
	//% call func('/// Set a single component by index from 0 to dim-1', match([0]), true)
	avl_ainl constexpr auto set($vecPar@& vec, const s::size_t idx, const $scalarPar@ scalar) noexcept(ndebug||exuse) -> void
	{
		static_assert($checkCmpType(vec, idx, scalar)@, $supplyScalar@);
		assert($checkDim(vec, idx)@);
		$vecWriteCmp(vec, idx, scalar)@;
	}
	test_case
	{
		$vecCreateZero(vec)@;
		const $arrCreateRnd(arr)@;
		
		//% for i in range(dim)
		set(vec, $i@, arr[$i@]);
		REQUIRE( get(vec, $i@) == Approx( arr[$i@] ) );
		//% endfor
	}
	//% endcall
	
	//% call func('/// Set a single component by static index from 0 to dim-1', match([0]), true)
	template<s::size_t _Idx> avl_ainl constexpr auto set($vecPar@& vec, const $scalarPar@ scalar) noexcept -> void
	{
		static_assert($checkCmpType(vec, _Idx, scalar)@, $supplyScalar@);
		static_assert($checkDim(vec, _Idx)@, "Index is out of range");
		$vecWriteCmp(vec, _Idx, scalar)@;
	}
	test_case
	{
		$vecCreateSeq(vec)@;
		const $arrCreateRnd(arr)@;
		
		//% for i in range(dim)
		set<$i@>(vec, arr[ $i@ ]);
		REQUIRE( get<$i@>(vec) == Approx( arr[$i@] ) );
		//% endfor
	}
	//% endcall
	
//% endcall
//% call section('Vector length operations')
	
	//% call func('/// Returns a new vector with the requested length', match([0]), true)
	avl_ainl_res constexpr auto setlen_mk(const $vecPar@& vec, const $scalarPar@ len_to_set) noexcept(ndebug||exuse)
	{
		const auto vec_len = len(vec);
		assert(vec_len!=cnst<decltype(vec_len)>::zero);
		return mul_mk(vec, len_to_set / vec_len);
	}
	test_case
	{
		const $vecCreateRnd(vec)@;
		const $scalarCreateRndPos('len_to_set')@;
		const auto new_vec = setlen_mk(vec, len_to_set);
		const auto len_new_vec = len(new_vec);
		
		REQUIRE( len_new_vec == Approx(len_to_set) );
		
		//test edge case 0.0
		const auto zero_len_vec = setlen_mk(vec, cnst<$scalarType()@>::zero);
		//% for i in range(dim)
		REQUIRE( get<$i@>(zero_len_vec) == Approx( cnst<$scalarType()@>::zero ) );
		//% endfor
	}
	//% endcall

//%for mut, rt, res, info in [('_set', '-> void', '', ''), ('', '-> decltype(vec)', '_res', ' and return the same vector (chained)')]
	//% call func('/// Set the length of the vector'+info, match([0]), true)
	avl_ainl$res@ constexpr auto setlen$mut@($vecPar@& vec, const $scalarPar@ len_to_set) noexcept(ndebug||exuse) $rt@
	{
		const auto vec_len = len(vec);
		assert(vec_len!=cnst<decltype(vec_len)>::zero);
		mul_set(vec, len_to_set / vec_len);
		//% if mut==''
		return vec;
		//% endif
	}
	test_case
	{
		$vecCreateRnd(vec)@;
		const $scalarCreateRndPos('len_to_set')@;
		$if_then(mut=='', 'const auto &ret_vec = ')@setlen$mut@(vec, len_to_set);
		const auto vec_len = len(vec);
		
		REQUIRE( vec_len == Approx(len_to_set) );
		
		//% if mut==''
		REQUIRE( &vec == &ret_vec);
		//% endif
		
		//test edge case 0.0
		$if_then(mut=='', 'const auto &ret_zero_vec = ')@setlen$mut@(vec, cnst<$scalarType()@>::zero);
		
		//% for i in range(dim)
		REQUIRE( get<$i@>(vec) == Approx( cnst<$scalarType()@>::zero ) );
		//% endfor
		
		//% if mut==''
		REQUIRE( &vec == &ret_zero_vec);
		//% endif
	}
	//% endcall
//% endfor
	
	//% call func('/// Calculate the length of the vector, prefere len_sqr when comparing distances', match([0]), true)
	avl_ainl_res constexpr auto len(const $vecPar@& vec) noexcept -> decltype(cmp(vec))
	{
		//len_sqr will never return any negativ values so we can gurantee noexcept
		const auto vec_square_len = len_sqr(vec);
		return static_cast<decltype(cmp(vec))>( s::sqrt( vec_square_len ) );
	}
	test_case
	{
		const $vecCreateRnd(vec)@;
		const auto vec_len = len(vec);
		const auto vec_square_len = /*% call loop_(range(dim), ' + ') %*/get<#>(vec) * get<#>(vec)/*% endcall %*/;
		REQUIRE( vec_len == Approx( s::sqrt( vec_square_len ) ) );
		
		//test edge case 0.0
		const $vecCreateZero('zero_vec')@;
		const auto zero_vec_len = len(zero_vec);
		REQUIRE( zero_vec_len == Approx( cnst<$scalarType()@>::zero ) );
	}
	//% endcall
	
	//% call func('/// Calculate the square length of the vector', match([2,3,4]))
	avl_ainl_res constexpr auto len_sqr(const $vecPar@& vec) noexcept -> decltype(cmp(vec))
	{
		//% for i in range(dim)
		const auto cmp$i@ = get<$i@>(vec);
		//% endfor
		return /*% call loop_(range(dim), ' + ') %*/cmp#*cmp#/*% endcall %*/;
	}
	test_case
	{
		const $vecCreateRnd(vec)@;
		const auto vec_len_sqr = len_sqr(vec);
		const auto vec_len_sqr_check = /*% call loop_(range(dim), ' + ') %*/get<#>(vec) * get<#>(vec)/*% endcall %*/;
		REQUIRE( vec_len_sqr == Approx( vec_len_sqr_check ) );
		
		//test edge case 0.0
		const $vecCreateZero('zero_vec')@;
		const auto zero_vec_len_sqr = len_sqr(zero_vec);
		REQUIRE( zero_vec_len_sqr == Approx( cnst<$scalarType()@>::zero ) );
	}
	//% endcall
	
//%- set altParamDesc = ', use alternative vector if the current vector length is 0'
//% for zeroLenParam, ex, info in [('', '(ndebug||exuse)', ''), (', const '+vecPar+'& vec_if_zero_len', '', altParamDesc)]
	//% call func('/// Returns a normalized vector' + info, match([0]), true)
	avl_ainl_res constexpr auto norm_mk(const $vecPar@& vec $zeroLenParam@) noexcept$ex@
	{
		const auto vec_len = len(vec);
		//% if zeroLenParam!=''
		if(vec_len==cnst<decltype(vec_len)>::zero)
			return vec_if_zero_len;
		//% endif
		return div_mk(vec, vec_len); //div might assert in debug
	}
	//%   if zeroLenParam==''
	test_case
	{
		
		const $vecCreateRnd(vec)@;
		const auto new_norm_vec = norm_mk(vec);
		const auto norm_len = len(new_norm_vec);
		REQUIRE( norm_len == Approx( cnst<$scalarType()@>::one ) );
	}
	//%   else
	test_case
	{
		const $vecCreateZero('zero_vec')@;
		const auto zero_len = len(zero_vec);
		REQUIRE( zero_len == Approx( cnst<$scalarType()@>::zero ) );
		
		$vecCreateZero(unit_vec)@;
		set<0>(unit_vec, cnst<$scalarType()@>::one);
		
		const auto new_unit_vec = norm_mk(zero_vec, unit_vec);
		const auto new_unit_vec_len = len(new_unit_vec);
		REQUIRE( new_unit_vec_len == Approx( cnst<$scalarType()@>::one ) );
		REQUIRE( get<0>(new_unit_vec) == Approx( cnst<$scalarType()@>::one ) );
	}
	//%   endif
	//% endcall
//% endfor
	
//% for mut, rt, res, info1 in [('_set', '-> void', '', ''), ('', '-> decltype(vec)', '_res', ' and return the same vector (chained)')]
//%   for zeroLenParam, info2 in [('', ''), (', const '+vecPar+'& vec_if_zero_len', altParamDesc)]
	//% call func('/// Normalize the current vector' + info1 + info2, match([0]), true)
	avl_ainl$res@ constexpr auto norm$mut@($vecPar@& vec $zeroLenParam@) noexcept $rt@
	{
		const auto vec_len = len(vec);
		//% if zeroLenParam!=''
		if(vec_len==cnst<decltype(vec_len)>::zero)
		{
			vec = vec_if_zero_len;
			//% if mut==''
			return vec;
			//%else
			return;
			//% endif
		}
		//% endif
		div_set(vec, vec_len); //div might assert in debug
		//% if mut==''
		return vec;
		//% endif
	}
	//%   if zeroLenParam==''
	test_case
	{
		$vecCreateRnd(vec)@;
		$if_then(mut=='', 'const auto &ret_vec = ')@norm$mut@(vec);
		const auto len_of_norm_vec = len(vec);
		REQUIRE( len_of_norm_vec == Approx( cnst<$scalarType()@>::one ) );
		//% if mut==''
		REQUIRE( &vec == &ret_vec);
		//% endif
	}
	//%   else
	test_case
	{
		$vecCreateZero(vec)@;
		const auto zero_len = len(vec);
		REQUIRE( zero_len == Approx( cnst<$scalarType()@>::zero ) );
		
		$vecCreateZero(unit_vec)@;
		set<0>(unit_vec, cnst<$scalarType()@>::one);
		
		$if_then(mut=='', 'const auto &ret_vec = ')@norm$mut@(vec, unit_vec);
		const auto vec_len = len(vec);
		REQUIRE( vec_len == Approx( cnst<$scalarType()@>::one ) );
		REQUIRE( get<0>(vec) == Approx( cnst<$scalarType()@>::one ) );
		//% if mut==''
		REQUIRE( &vec == &ret_vec);
		//% endif
	}
	//%   endif
	//% endcall
//%   endfor
//% endfor
	
//% endcall
//% call section('Spacial operations')
//% for mut, mul, info in [('_rd', '', 'radian'),('_dg', ' * cnst<decltype(cmp(vec))>::to_deg', 'degree')]
	//% call func('/// Calculate the angle between two vectors in '+info, match([0]), true)
	avl_ainl_res constexpr auto angle$mut@(const $vecPar@& vec, const decltype(vec) other) noexcept -> decltype(cmp(vec))
	{
		const auto vec_len		= len(vec);
		const auto other_len	= len(other);
		const auto dot_prod		= dot(vec, other);
		return s::acos( dot_prod / ( vec_len * other_len ) )$mul@;
	}
	test_case
	{
		const $scalarCreateRndPos('random_len1')@;
		const $scalarCreateRndPos('random_len2')@;
		const $scalarCreateRndPos('random_len3')@;
		const $scalarCreateRndPos('random_len4')@;
		
		$vecCreateZero('vec_zero')@;
		$vecCreateZero('vec_10x')@;
		set<0>(vec_10x, random_len1);
		$vecCreateZero('vec_01x')@;
		set<1>(vec_01x, random_len2);
		$vecCreateZero('vec_m10x')@;
		set<0>(vec_m10x, -random_len3);
		$vecCreateZero('vec_11x')@;
		set<0>(vec_11x, random_len4);
		set<1>(vec_11x, random_len4);
		
		//TODO: add case for edge case with zero vec
		
		const auto angle0 = angle$mut@(vec_10x, vec_10x);
		REQUIRE( angle0 == Approx( cnst<$scalarType()@>::zero ) );
		
		const auto angle90 = angle$mut@(vec_10x, vec_01x);
		REQUIRE( angle90 == Approx( $if_then_else(mut=='_rd', deg_to_rad(90), 90)@ ) );
		
		const auto angle45a = angle$mut@(vec_10x, vec_11x);
		REQUIRE( angle45a == Approx( $if_then_else(mut=='_rd', deg_to_rad(45), 45)@ ) );
		const auto angle45b = angle$mut@(vec_01x, vec_11x);
		REQUIRE( angle45b == Approx( $if_then_else(mut=='_rd', deg_to_rad(45), 45)@ ) );
		
		const auto angle135 = angle$mut@(vec_m10x, vec_11x);
		REQUIRE( angle135 == Approx( $if_then_else(mut=='_rd', deg_to_rad(135), 135)@ ) );
		
		const auto angle180 = angle$mut@(vec_10x, vec_m10x);
		REQUIRE( angle180 == Approx( $if_then_else(mut=='_rd', deg_to_rad(180), 180)@ ) );
	}
	//%   if dim>=3
	test_case
	{
		const $scalarCreateRndPos('random_len1')@;
		const $scalarCreateRndPos('random_len2')@;
		const $scalarCreateRndPos('random_len3')@;
		const $scalarCreateRndPos('random_len4')@;
		
		$vecCreateZero('vec_zero')@;
		$vecCreateZero('vec_010x')@;
		set<1>(vec_010x, random_len1);
		$vecCreateZero('vec_001x')@;
		set<2>(vec_001x, random_len2);
		$vecCreateZero('vec_0m10x')@;
		set<1>(vec_0m10x, -random_len3);
		$vecCreateZero('vec_011x')@;
		set<1>(vec_011x, random_len4);
		set<2>(vec_011x, random_len4);
		
		const auto angle0 = angle$mut@(vec_010x, vec_010x);
		REQUIRE( angle0 == Approx( cnst<$scalarType()@>::zero ) );
		
		const auto angle90 = angle$mut@(vec_010x, vec_001x);
		REQUIRE( angle90 == Approx( $if_then_else(mut=='_rd', deg_to_rad(90), 90)@ ) );
		
		const auto angle45a = angle$mut@(vec_010x, vec_011x);
		REQUIRE( angle45a == Approx( $if_then_else(mut=='_rd', deg_to_rad(45), 45)@ ) );
		const auto angle45b = angle$mut@(vec_001x, vec_011x);
		REQUIRE( angle45b == Approx( $if_then_else(mut=='_rd', deg_to_rad(45), 45)@ ) );
		
		const auto angle135 = angle$mut@(vec_0m10x, vec_011x);
		REQUIRE( angle135 == Approx( $if_then_else(mut=='_rd', deg_to_rad(135), 135)@ ) );
		
		const auto angle180 = angle$mut@(vec_010x, vec_0m10x);
		REQUIRE( angle180 == Approx( $if_then_else(mut=='_rd', deg_to_rad(180), 180)@ ) );
	}
	//%   endif
	//%   if dim>=4
	test_case
	{
		const $scalarCreateRndPos('random_len1')@;
		const $scalarCreateRndPos('random_len2')@;
		const $scalarCreateRndPos('random_len3')@;
		const $scalarCreateRndPos('random_len4')@;
		
		$vecCreateZero('vec_zero')@;
		$vecCreateZero('vec_0010')@;
		set<2>(vec_0010, random_len1);
		$vecCreateZero('vec_0001')@;
		set<3>(vec_0001, random_len2);
		$vecCreateZero('vec_00m10')@;
		set<2>(vec_00m10, -random_len3);
		$vecCreateZero('vec_0011')@;
		set<2>(vec_0011, random_len4);
		set<3>(vec_0011, random_len4);
		
		const auto angle0 = angle$mut@(vec_0010, vec_0010);
		REQUIRE( angle0 == Approx( cnst<$scalarType()@>::zero ) );
		
		const auto angle90 = angle$mut@(vec_0010, vec_0001);
		REQUIRE( angle90 == Approx( $if_then_else(mut=='_rd', deg_to_rad(90), 90)@ ) );
		
		const auto angle45a = angle$mut@(vec_0010, vec_0011);
		REQUIRE( angle45a == Approx( $if_then_else(mut=='_rd', deg_to_rad(45), 45)@ ) );
		const auto angle45b = angle$mut@(vec_0001, vec_0011);
		REQUIRE( angle45b == Approx( $if_then_else(mut=='_rd', deg_to_rad(45), 45)@ ) );
		
		const auto angle135 = angle$mut@(vec_00m10, vec_0011);
		REQUIRE( angle135 == Approx( $if_then_else(mut=='_rd', deg_to_rad(135), 135)@ ) );
		
		const auto angle180 = angle$mut@(vec_0010, vec_00m10);
		REQUIRE( angle180 == Approx( $if_then_else(mut=='_rd', deg_to_rad(180), 180)@ ) );
	}
	//%   endif
	//% endcall
//% endfor
	//% call func('/// Calculate the area of the spawned triangle'+if_then(dim==4,' (restricted to 3 dimensions)'), match([2,3,4]))
	avl_inl_res constexpr auto area$if_then(dim==4,'3')+'('+if_then_else(dim==2, 'const '+vecPar+'&', vecPar)@ vec, const decltype(vec)& other) noexcept -> decltype(cmp(vec))
	{
		//% if dim==2
		using scalar = decltype(cmp(vec));
		const auto area = cnst<scalar>::half*(get<0>(vec) * get<1>(other) - get<1>(vec) * get<0>(other));
		return area < cnst<scalar>::zero
			? -area
			: area;
		//% else
		return cnst<decltype(cmp(vec))>::half * len( cross$if_then(dim==4,'3')@(vec, other) );
		//% endif
	}
	test_case
	{
		$vecCreateZero('vec_0')@;
		$vecCreateZero('vec_1')@;
		$vecCreateZero('vec_2')@;
		set<0>(vec_0, cnst<$scalarType()@>::one);
		set<1>(vec_1, cnst<$scalarType()@>::one);
		set<0>(vec_2, cnst<$scalarType()@>::minus_one);
		
		const auto a0 = area$if_then(dim==4,'3')@(vec_0, vec_1);
		REQUIRE( a0 == cnst<$scalarType()@>::half );
		
		const auto a1 = area$if_then(dim==4,'3')@(vec_0, vec_0);
		REQUIRE( a1 == cnst<$scalarType()@>::zero );
		
		const auto a2 = area$if_then(dim==4,'3')@(vec_0, vec_2);
		REQUIRE( a2 == cnst<$scalarType()@>::zero );
	}
	//% endcall
	
//%  for mut, rt, res in [('_mk', '', '_res'), ('_set', ' -> void', ''), ('', ' -> decltype(vec)', '_res')]
	//% call func('/// Calculate the cross product'+if_then(dim==4,' (restricted to 3 dimensions)'), match([3,4]))
	avl_ainl$res@ constexpr auto cross$if_then(dim==4,'3')+mut@($if_then(mut=='_mk', 'const ')+vecPar@& vec, const $vecPar@& other) noexcept$rt@
	{
		//% if mut=='_mk'
		return rem_const_ref_t<decltype(vec)> {
		//% else
		set_all( vec,
		//% endif
				get<1>(vec) * get<2>(other) - get<2>(vec) * get<1>(other),
				get<2>(vec) * get<0>(other) - get<0>(vec) * get<2>(other),
				get<0>(vec) * get<1>(other) - get<1>(vec) * get<0>(other)/*% if dim==4 %*/,
				cnst<decltype(cmp(vec))>::zero
				/*% endif %*/
		//% if mut=='_mk'
			};
		//% else
			);
		//%   if mut==''
		return vec;
		//%   endif
		//% endif
	}
	test_case
	{
		$vecCreateZero('vec_100x')@;
		$vecCreateZero('vec_100x_dup')@;
		$vecCreateZero('vec_010x')@;
		$vecCreateZero('expected_res1')@;
		$vecCreateZero('expected_res2')@;
		set<0>(vec_100x, cnst<$scalarType()@>::one);
		set<0>(vec_100x_dup, cnst<$scalarType()@>::one);
		set<1>(vec_010x, cnst<$scalarType()@>::one);
		set<2>(expected_res1, cnst<$scalarType()@>::one);
		set<2>(expected_res2, cnst<$scalarType()@>::minus_one);
		
		//% if mut=='_mk'
		auto result1 = cross$if_then(dim==4, '3')@_mk(vec_100x, vec_010x);
		auto result2 = cross$if_then(dim==4, '3')@_mk(vec_010x, vec_100x_dup);
		//% elif mut=='_set'
		cross$if_then(dim==4, '3')@_set(vec_100x, vec_010x);
		cross$if_then(dim==4, '3')@_set(vec_010x, vec_100x_dup);
		//% else
		auto &result1 = cross$if_then(dim==4, '3')@(vec_100x, vec_010x);
		auto &result2 = cross$if_then(dim==4, '3')@(vec_010x, vec_100x_dup);
		//% endif
		
		//% for i in range(dim)
		//%   if mut=='_set'
		REQUIRE( get<$i@>(vec_100x) == Approx( get<$i@>(expected_res1) ) );
		//%   else
		REQUIRE( get<$i@>(result1) == Approx( get<$i@>(expected_res1) ) );
		//%   endif
		//%  endfor
		
		
		//% for i in range(dim)
		//%   if mut=='_set'
		REQUIRE( get<$i@>(vec_010x) == Approx( get<$i@>(expected_res2) ) );
		//%   else
		REQUIRE( get<$i@>(result2) == Approx( get<$i@>(expected_res2) ) );
		//%   endif
		//%  endfor
	}
	//% endcall
//%   endfor
//% endcall
//% call section('Getter and setters for '+dim|string+' component vectors', match([2,3,4]))
	
	//% call func('/// Set all vector components to the same scalar', match([2,3,4]))
	avl_ainl constexpr auto set_all($vecPar@& vec, const $scalarPar@ scalar) noexcept -> void
	{
		static_assert(eq<decltype(vec[0]), decltype(scalar)>::value, "Supply a scalar of the vectors element filetype.");
		//% for i in range(dim)
		$vecWriteCmp(vec, i, scalar)@;
		//% endfor
	}
	test_case
	{
		$vecCreateZero(vec)@;
		
		const $scalarCreateRnd('val')@;
		
		set_all(vec, val);
		
		//% for i in range(dim)
		REQUIRE( get<$i@>(vec)==val );
		//% endfor
	}
	//% endcall
	
	//% call func('/// Set all vector components individually', match([2,3,4]))
	avl_ainl constexpr auto set_all($vecPar@& vec/*% for name in param %*/, const $scalarPar@ $name@/*% endfor %*/) noexcept -> void
	{
		//% for i in range(dim)
		static_assert(eq<decltype(vec[ $i@ ]), decltype($param[i]@)>::value, "Supply a scalar of the vectors element type for $param[i]@.");
		//% endfor
		
		//% for i in range(dim)
		$vecWriteCmp(vec, i, param[i])@;
		//% endfor
	}
	test_case
	{
		$vecCreateZero(vec)@;
		const $arrCreateRnd(arr)@;
		
		set_all(vec,/*% call loop_(range(dim)) %*/arr[#]/*% endcall %*/);
		
		//% for i in range(dim)
		REQUIRE( get<$i@>(vec)==arr[$i@] );
		//% endfor
	}
	//% endcall
	
	//% call func('/// Set all vector components individually by a fixed size array', match([2,3,4]))
	avl_ainl constexpr auto set_all($vecPar@& vec, const $scalarPar@ scalars[ $dim@ ]) noexcept -> void
	{
		//% for i in range(dim)
		static_assert(eq<decltype(vec[ $i@ ]), decltype(scalars[ $i@ ])>::value, "Supply a scalar of the vectors element filetype.");
		//% endfor
		
		//% for i in range(dim)
		$vecWriteCmp(vec, i, 'scalars[' + i|string + ']')@;
		//% endfor
	}
	test_case
	{
		$vecCreateZero(vec)@;
		const $arrCreateRnd(arr)@;
		
		set_all(vec, arr);
		
		//% for i in range(dim)
		REQUIRE( get<$i@>(vec)==arr[$i@] );
		//% endfor
	}
	//% endcall
	
	//% call func('/// Set all vector components individually by an array', match([2,3,4]))
	template <s::size_t _Dim> avl_ainl constexpr auto set_all($vecPar@& vec, const $scalarPar@* scalars) noexcept -> void
	{
		static_assert(_Dim>=$dim@, "Supply at least $dim@ scalars.");
		//% for i in range(dim)
		static_assert(eq<decltype(vec[ $i@ ]), decltype(scalars[ $i@ ])>::value, "Supply a scalar of the vectors element type.");
		//% endfor
		
		//% for i in range(dim)
		$vecWriteCmp(vec, i, 'scalars[' + i|string + ']')@;
		//% endfor
	}
	test_case
	{
		$vecCreateZero(vec)@;
		const $arrCreateRnd(arr)@;
		const auto* ptr_to_arr = arr;
		
		set_all<$dim@>(vec, ptr_to_arr);
		
		//% for i in range(dim)
		REQUIRE( get<$i@>(vec)==arr[$i@] );
		//% endfor
	}
	//% endcall
	
//% endcall
//% call section('General vector operations for '+dim|string+' component vectors', match([2,3,4]))
//% for op, s in [('add', '+'), ('sub', '-'), ('mul', '*'), ('div', '/')]
//%   if filetype=='test'
	$vecCreateRnd(op+'_var_1')@;
	$vecCreateRnd(op+'_var_2')@;
	const $scalarCreateRnd(op+'_scalar')@;
	
	const $arrCreate(op+'_vec_res')@ =
		{ /*% call loop_(range(dim)) %*/get<#>($op@_var_1) $s@ get<#>($op@_var_2)/*% endcall %*/ };
	const $arrCreate(op+'_scalar_res')@ =
		{ /*% call loop_(range(dim)) %*/get<#>($op@_var_1) $s@ $op@_scalar/*% endcall %*/ };
	const $arrCreate(op+'_vec_scalar_res')@ =
		{ /*% call loop_(range(dim)) %*/get<#>($op@_var_1) $s@ get<#>($op@_var_2) $s@ $op@_scalar/*% endcall %*/ };
	
//%   endif
//% endfor
//% for op, s in [('add', '+'), ('sub', '-'), ('mul', '*'), ('div', '/')]
//%   for mut, rt, res in [('_mk', '', '_res'), ('_set', ' -> void', ''), ('', ' -> decltype(vec)', '_res')]
	
	//% call func('// ' + op + mut, match([2,3,4]))
	avl_ainl$res@ constexpr auto $op+mut@($if_then(mut=='_mk', 'const ')+vecPar@& vec, const $vecPar@& other) noexcept$if_then(op=='div', '(ndebug||exuse)')+rt@
	{
		//% call loop_if(op=='div', range(dim), '')
		assert(get<#>(other)!=cnst<decltype(cmp(other))>::zero);
		//% endcall
		
		//% if mut=='_mk'
		return rem_const_ref_t< decltype(vec) >
					{/*% call loop_(range(dim)) %*/get<#>(vec) $s@ get<#>(other)/*% endcall %*/ };
		//% elif mut=='_set'
		set_all(vec, /*% call loop_(range(dim)) %*/get<#>(vec) $s@ get<#>(other)/*% endcall %*/ );
		//% else
		set_all(vec, /*% call loop_(range(dim)) %*/get<#>(vec) $s@ get<#>(other)/*% endcall %*/ );
		return vec;
		//% endif
	}
	//%   if mut=='_mk'
	test_case
	{
		auto res = $op+mut@($op@_var_1, $op@_var_2);
		//% call loop_(range(dim), '')
		REQUIRE( get<#>(res) == Approx($op@_vec_res[#]) );
		//% endcall
		REQUIRE( &res != &$op@_var_1 ); //result must be a new resource
		REQUIRE( &res != &$op@_var_2 ); //also different to $op@_var_2
	}
	//%   elif mut=='_set'
	test_case
	{
		$op+mut@($op@_var_1, $op@_var_2);
		//% call loop_(range(dim), '')
		REQUIRE( get<#>($op@_var_1) == Approx($op@_vec_res[#]) );
		//% endcall
	}
	//%   else
	test_case
	{
		auto &res = $op+mut@($op@_var_1, $op@_var_2);
		//% call loop_(range(dim), '')
		REQUIRE( get<#>(res) == Approx($op@_vec_res[#]) );
		//% endcall
		REQUIRE( &res == &$op@_var_1 );//result must be $op@_var_1
		REQUIRE( &res != &$op@_var_2 );//but not $op@_var_2
		auto &res2 = $op+mut@(res, $op@_scalar);
		//% call loop_(range(dim), '')
		REQUIRE( get<#>(res2) == Approx($op@_vec_scalar_res[#]) );
		//% endcall
		REQUIRE( &res2 == &$op@_var_1 );//result must be $op@_var_1
	}
	//%   endif
	//% endcall
	
	//% call func('// ' + op + mut +' (scalar)', match([2,3,4]))
	avl_ainl$res@ constexpr auto $op+mut@($if_then(mut=='_mk', 'const ')+vecPar@& vec, const $scalarPar@ scalar) noexcept$if_then(op=='div', '(ndebug||exuse)')+rt@
	{
		//% if op=='div'
		assert(scalar!=cnst<decltype(scalar)>::zero);
		//% endif
		
		//% if mut=='_mk'
		return rem_const_ref_t< decltype(vec) >
					{/*% call loop_(range(dim)) %*/get<#>(vec) $s@ scalar/*% endcall %*/ };
		//% elif mut=='_set'
		set_all(vec, /*% call loop_(range(dim)) %*/get<#>(vec) $s@ scalar/*% endcall %*/ );
		//% else
		set_all(vec, /*% call loop_(range(dim)) %*/get<#>(vec) $s@ scalar/*% endcall %*/ );
		return vec;
		//% endif
	}
	//%   if mut=='_mk'
	test_case
	{
		auto res = $op+mut@($op@_var_1, $op@_scalar);
		//% call loop_(range(dim), '')
		REQUIRE( get<#>(res) == Approx($op@_scalar_res[#]) );
		//% endcall
		REQUIRE( &res != &$op@_var_1 ); //result must be a new resource
	}
	//%   elif mut=='_set'
	test_case
	{
		$op+mut@($op@_var_1, $op@_scalar);
		//% call loop_(range(dim), '')
		REQUIRE( get<#>($op@_var_1) == Approx($op@_scalar_res[#]) );
		//% endcall
	}
	//%   else
	test_case
	{
		auto &res = $op+mut@($op@_var_1, $op@_scalar);
		//% call loop_(range(dim), '')
		REQUIRE( get<#>(res) == Approx($op@_scalar_res[#]) );
		//% endcall
		REQUIRE( &res == &$op@_var_1 );//result must be $op@_var_1
		auto &res2 = $op+mut@(res, $op@_var_2);
		//% call loop_(range(dim), '')
		REQUIRE( get<#>(res2) == Approx($op@_vec_scalar_res[#]) );
		//% endcall
		REQUIRE( &res2 == &$op@_var_1 );//result must be $op@_var_1
	}
	//%   endif
	//% endcall
	
//%   endfor
//% endfor
//% endcall
//% call section('General purpos functions for '+dim|string+' component vectors', match([2,3,4]))
	
	//% call func('/// Dot product', match([2,3,4]))
	avl_ainl constexpr auto dot(const $vecPar@& vec, decltype(vec)& other) noexcept -> decltype(cmp(vec))
	{
		return /*% call loop_(range(dim), ' + ') %*/get<#>(vec) * get<#>(other)/*% endcall %*/;
	}
	test_case
	{
		
	}
	//% endcall
	
	//% call func('/// Dot product ignoring the w component', match([4]))
	avl_ainl constexpr auto dot3(const $vecPar@& vec, decltype(vec)& other) noexcept -> decltype(cmp(vec))
	{
		return /*% call loop_(range(dim-1), ' + ') %*/get<#>(vec) * get<#>(other)/*% endcall %*/;
	}
	test_case
	{
		
	}
	//% endcall
//% endcall

//% if filetype!='test'
}
#endif // AVL_$filename.upper()@_$filetype.upper()@
//%- endif